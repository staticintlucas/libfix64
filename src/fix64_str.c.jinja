{#- jinja2 template for fix64_str.c -#}

{{autogen_comment}}

#define FIX64_INTERNAL
#include "fix64.h"

#include <stddef.h>
#include <stdint.h>

static inline unsigned clz(uint32_t arg) {
    unsigned result;
    #if __has_builtin(__builtin_clz)
        // clz has UB when arg == 0, and log2 is also undefined. But 0 still has 1 digit so we
        // or with 1 to return 31 in this case
        result = __builtin_clz(arg | 1);
    #else
        result = 0;
        for (uint32_t sh = (CHAR_BIT * sizeof(uint32_t)) >> 1; sh; sh >>= 1) {
            uint32_t tmp = arg >> sh;
            if (tmp) {
                arg = tmp;
            } else {
                result |= sh;
            }
        }
    #endif
    return result;
}

// Algorithm to calculate number of decimal digits based on https://commaok.xyz/post/lookup_tables/
// and https://lemire.me/blog/2021/06/03/computing-the-number-of-digits-of-an-integer-even-faster/
static unsigned digits(uint32_t arg) {
    static uint64_t table[] = {
        // len(str(2**i)) << 32 | 2**32 - 10**len(str(2**i))
{% for coef in digit_coefs %}
        UINT64_C({{"{:#03x}".format(coef[0])}}) << 32 | UINT64_C({{"{:#010x}".format(coef[1])}}),
{% endfor %}
    };
    return (arg + table[31 - clz(arg)]) >> 32;
}

size_t fix64_to_str(char *buf, fix64_t val, size_t size) {

    static const unsigned prec = 5;
    static const unsigned rounding = 21475; // = 0.5 / 10^prec * 2^FIX64_FRAC_BITS
    char tmpbuf[256];
    char *tmpptr = tmpbuf;

    uint64_t repr = val.repr;
    if (val.repr < 0) {
        *tmpptr++ = '-';
        repr = UINT64_C(0) - val.repr;
    }
    repr += rounding;

    uint64_t ipart = repr >> FIX64_FRAC_BITS;
    uint64_t fpart = repr & ((UINT64_C(1) << FIX64_FRAC_BITS) - 1);

    tmpptr += digits(ipart);
    char *istart = tmpptr - 1;
    do {
        *istart-- = '0' + (ipart % 10);
        ipart /= 10;
    } while(ipart);

    *tmpptr++ = '.';
    for (size_t i = 0; i < prec; i++) {
        fpart *= 10;
        *tmpptr++ = '0' + (fpart >> FIX64_FRAC_BITS);
        fpart &= ((UINT64_C(1) << FIX64_FRAC_BITS) - 1);
    }

    size_t len = tmpptr - tmpbuf;
    size_t end = (len > size) ? size : len;

    for (size_t i = 0; i < end; i++) {
        buf[i] = tmpbuf[i];
    }
    buf[end] = 0;

    return len;
}
