{#- jinja2 template for fix64_trig.c -#}

{{autogen_comment}}

{% set cheby_frac_bits = 62 %}

#include "fix64.h"

#include <stddef.h>
#include <stdint.h>

// Number fractional bits
#define CHEBYSHEV_FRAC_BITS {{cheby_frac_bits}}

// Use this instead of FIX64_4_PI for accuracy
#define CHEBYSHEV_2_PI {{const(2 / consts.pi.val, frac_bits=cheby_frac_bits)}}

{% for func in ["sin", "cos", "tan"] %}
static int64_t chebyshev_{{func}}_impl(int64_t value) {
    // Coefficients for the chebyshev series
    static const int64_t chebyshev_coefs[{{chebyshev_coefs[func] | length}}] = {
{% for coef in chebyshev_coefs[func] %}
        {{const(coef, frac_bits=cheby_frac_bits, digits=16)}},
{% endfor %}
    };

    int64_t val_pow[{{chebyshev_coefs[func] | length}}];
    val_pow[0] = INT64_C(1) << CHEBYSHEV_FRAC_BITS;
    for (size_t i = 1; i < sizeof(val_pow) / sizeof(val_pow[0]); i++) {
        val_pow[i] = ((int128_t)val_pow[i - 1] * value) >> CHEBYSHEV_FRAC_BITS;
    }

    int64_t sum = 0;
    for (size_t i = 0; i < sizeof(chebyshev_coefs) / sizeof(chebyshev_coefs[0]); i++) {
        sum += ((int128_t)val_pow[i] * chebyshev_coefs[i]) >> CHEBYSHEV_FRAC_BITS;
    }

    return sum; // Q1.62
}

{% endfor -%}

fix64_t fix64_sin(fix64_t angle) {
    // Normalise so that 1.0 = pi/2 = 90deg
    int128_t a = (int128_t)angle.repr * CHEBYSHEV_2_PI; // Q31.94

    // Calculate octant, used to determine which chebyshev function to call
    unsigned octant = (a >> (CHEBYSHEV_FRAC_BITS + FIX64_FRAC_BITS - 1)) & 0x7;
    // Modulo pi/2 (90deg)
    a &= ((int128_t)1 << (CHEBYSHEV_FRAC_BITS + FIX64_FRAC_BITS)) - 1; // UQ0.94

    // Normalise -pi/4..pi/4 (90deg) to range -1..1 with CHEBYSHEV_FRAC_BITS fractional bits
    int64_t norm_a = (a >> (FIX64_FRAC_BITS - 1)); // UQ2.62
    norm_a = (((norm_a + (1ul << CHEBYSHEV_FRAC_BITS)) &
        (((int128_t)2ul << CHEBYSHEV_FRAC_BITS) - 1)) - (1ul << CHEBYSHEV_FRAC_BITS)); // Q1.62

    int64_t result = 0;
    switch (octant) {
        case 7:
        case 0:
            result = chebyshev_sin_impl(norm_a);
            break;
        case 1:
        case 2:
            result = chebyshev_cos_impl(norm_a);
            break;
        case 3:
        case 4:
            result = -chebyshev_sin_impl(norm_a);
            break;
        case 5:
        case 6:
            result = -chebyshev_cos_impl(norm_a);
            break;
    }

    // Round to Q31.32
    result += (INT64_C(1) << (CHEBYSHEV_FRAC_BITS - FIX64_FRAC_BITS - 1)); // rounding
    result >>= (CHEBYSHEV_FRAC_BITS - FIX64_FRAC_BITS); // Q31.32

    return (fix64_t){ result };
}

fix64_t fix64_cos(fix64_t angle) {
    // Normalise so that 1.0 = pi/2 = 90deg
    int128_t a = (int128_t)angle.repr * CHEBYSHEV_2_PI; // Q31.94

    // Calculate octant, used to determine which chebyshev function to call
    unsigned octant = (a >> (CHEBYSHEV_FRAC_BITS + FIX64_FRAC_BITS - 1)) & 0x7;
    // Modulo pi/2 (90deg)
    a &= ((int128_t)1 << (CHEBYSHEV_FRAC_BITS + FIX64_FRAC_BITS)) - 1; // Q0.94

    // Normalise -pi/4..pi/4 (90deg) to range -1..1 with CHEBYSHEV_FRAC_BITS fractional bits
    int64_t norm_a = (a >> (FIX64_FRAC_BITS - 1)); // UQ2.62
    norm_a = (((norm_a + (1ul << CHEBYSHEV_FRAC_BITS)) &
        (((int128_t)2ul << CHEBYSHEV_FRAC_BITS) - 1)) - (1ul << CHEBYSHEV_FRAC_BITS)); // Q1.62

    int64_t result = 0;
    switch (octant) {
        case 7:
        case 0:
            result = chebyshev_cos_impl(norm_a);
            break;
        case 1:
        case 2:
            result = -chebyshev_sin_impl(norm_a);
            break;
        case 3:
        case 4:
            result = -chebyshev_cos_impl(norm_a);
            break;
        case 5:
        case 6:
            result = chebyshev_sin_impl(norm_a);
            break;
    }

    // Round to Q31.32
    result += (INT64_C(1) << (CHEBYSHEV_FRAC_BITS - FIX64_FRAC_BITS - 1)); // rounding
    result >>= (CHEBYSHEV_FRAC_BITS - FIX64_FRAC_BITS); // Q31.32

    return (fix64_t){ result };
}

fix64_t fix64_tan(fix64_t angle) {
    // Normalise so that 1.0 = pi/2 = 90deg
    int128_t a = (int128_t)angle.repr * CHEBYSHEV_2_PI; // Q31.94

    // Calculate octant, used to determine which chebyshev function to call
    unsigned octant = (a >> (CHEBYSHEV_FRAC_BITS + FIX64_FRAC_BITS - 1)) & 0x7;
    // Modulo pi/2 (90deg)
    a &= ((int128_t)1 << (CHEBYSHEV_FRAC_BITS + FIX64_FRAC_BITS)) - 1; // UQ0.94

    // Normalise -pi/4..pi/4 (90deg) to range -1..1 with CHEBYSHEV_FRAC_BITS fractional bits
    int64_t norm_a = (a >> (FIX64_FRAC_BITS - 1)); // UQ2.62
    norm_a = (((norm_a + (1ul << CHEBYSHEV_FRAC_BITS)) &
        (((int128_t)2ul << CHEBYSHEV_FRAC_BITS) - 1)) - (1ul << CHEBYSHEV_FRAC_BITS)); // Q1.62

    int128_t result = 0;
    switch (octant) {
        case 7:
        case 0:
        case 3:
        case 4:
            result = chebyshev_tan_impl(norm_a);
            break;
        case 1:
        case 2:
        case 5:
        case 6:
            result = chebyshev_tan_impl(-norm_a);
            if (!result) {
                return FIX64_MAX;
            }
            result = ((int128_t)1 << (2 * CHEBYSHEV_FRAC_BITS)) / result;
            break;
    }

    // Round to Q93.32
    result += (INT64_C(1) << (CHEBYSHEV_FRAC_BITS - FIX64_FRAC_BITS - 1)); // rounding
    result >>= (CHEBYSHEV_FRAC_BITS - FIX64_FRAC_BITS); // Q31.32

    // Saturate result
    if (FIX64_UNLIKELY(result > INT64_MAX)) {
        result = INT64_MAX;
    } else if (FIX64_UNLIKELY(result < INT64_MIN)) {
        result = INT64_MIN;
    }

    return (fix64_t){ result };
}
