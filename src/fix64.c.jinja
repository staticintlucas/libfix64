{#- jinja2 template for fix64.c -#}

{{autogen_comment}}

#include "fix64.h"

#include <stddef.h>
#include <stdint.h>

// Number fractional bits
#define CHEBYSHEV_FRAC_BITS {{chebyshev.frac_bits}}

// Use this instead of {{type | upper}}_4_PI for accuracy
#define CHEBYSHEV_4_PI {{chebyshev.const(4 / consts.pi)}}

{% for func in ["sin", "cos", "tan"] %}
static {{repr.type}}_t chebyshev_{{func}}_impl({{repr.type}}_t value) {
    // Coefficients for the chebyshev series
    static const {{repr.type}}_t chebyshev_coefs[{{chebyshev[func].coefs | length}}] = {
{% for coef in chebyshev[func].coefs %}
        {{chebyshev.const(coef, "x", 16)}},
{% endfor %}
    };

    {{repr.type}}_t val_pow[{{chebyshev[func].coefs | length}}];
    val_pow[0] = {{repr.const(1)}} << CHEBYSHEV_FRAC_BITS;
    for (size_t i = 1; i < sizeof(val_pow) / sizeof(val_pow[0]); i++) {
        val_pow[i] = ((int128_t)val_pow[i - 1] * value) >> CHEBYSHEV_FRAC_BITS;
    }

    {{repr.type}}_t sum = 0;
    for (size_t i = 0; i < sizeof(chebyshev_coefs) / sizeof(chebyshev_coefs[0]); i++) {
        sum += ((int128_t)val_pow[i] * chebyshev_coefs[i]) >> CHEBYSHEV_FRAC_BITS;
    }
    sum += ({{repr.const(1)}} << (CHEBYSHEV_FRAC_BITS - {{type | upper}}_FRAC_BITS - 1)); // rounding
    sum >>= (CHEBYSHEV_FRAC_BITS - {{type | upper}}_FRAC_BITS); // Q32.32

    return sum;
}

{% endfor -%}

{{type}}_t {{type}}_sin({{type}}_t angle) {
    // Normalise so that 1.0 = pi/4 = 45deg
    int128_t a = (int128_t)angle.repr * CHEBYSHEV_4_PI; // Q31.94
    // Modulo 8 => between 0 and 2*pi (360deg)
    a = a & (((int128_t)8 << (CHEBYSHEV_FRAC_BITS + {{type | upper}}_FRAC_BITS)) - 1); // Q3.94

    // Calculate octant, used to determine which chebyshev function to call
    unsigned octant = (a >> (CHEBYSHEV_FRAC_BITS + {{type | upper}}_FRAC_BITS));
    // Modulo pi/4 (45deg)
    a &= ((int128_t)1 << (CHEBYSHEV_FRAC_BITS + {{type | upper}}_FRAC_BITS)) - 1; // Q0.94

    // Normalise 0..pi/4 (45deg) to range -1..1 with CHEBYSHEV_FRAC_BITS fractional bits
    {{repr.type}}_t norm_a = {{chebyshev.const(-1)}} + (a >> ({{type | upper}}_FRAC_BITS - 1)); // Q1.62

    {{repr.type}}_t result;
    if (octant == 0) {
        result = chebyshev_sin_impl(norm_a);
    } else if (octant == 1) {
        result = chebyshev_cos_impl(-norm_a);
    } else if (octant == 2) {
        result = chebyshev_cos_impl(norm_a);
    } else if (octant == 3) {
        result = chebyshev_sin_impl(-norm_a);
    } else if (octant == 4) {
        result = -chebyshev_sin_impl(norm_a);
    } else if (octant == 5) {
        result = -chebyshev_cos_impl(-norm_a);
    } else if (octant == 6) {
        result = -chebyshev_cos_impl(norm_a);
    } else if (octant == 7) {
        result = -chebyshev_sin_impl(-norm_a);
    }

    return ({{type}}_t){ result };
}

{{type}}_t {{type}}_cos({{type}}_t angle) {
    // Normalise so that 1.0 = pi/4 = 45deg
    int128_t a = (int128_t)angle.repr * CHEBYSHEV_4_PI; // Q31.94
    // Modulo 8 => between 0 and 2*pi (360deg)
    a = a & (((int128_t)8 << (CHEBYSHEV_FRAC_BITS + {{type | upper}}_FRAC_BITS)) - 1); // Q3.94

    // Calculate octant, used to determine which chebyshev function to call
    unsigned octant = (a >> (CHEBYSHEV_FRAC_BITS + {{type | upper}}_FRAC_BITS));
    // Modulo pi/4 (45deg)
    a &= ((int128_t)1 << (CHEBYSHEV_FRAC_BITS + {{type | upper}}_FRAC_BITS)) - 1; // Q0.94

    // Normalise 0..pi/4 (45deg) to range -1..1 with CHEBYSHEV_FRAC_BITS fractional bits
    {{repr.type}}_t norm_a = {{chebyshev.const(-1)}} + (a >> ({{type | upper}}_FRAC_BITS - 1)); // Q1.62

    {{repr.type}}_t result;
    if (octant == 0) {
        result = chebyshev_cos_impl(norm_a);
    } else if (octant == 1) {
        result = chebyshev_sin_impl(-norm_a);
    } else if (octant == 2) {
        result = -chebyshev_sin_impl(norm_a);
    } else if (octant == 3) {
        result = -chebyshev_cos_impl(-norm_a);
    } else if (octant == 4) {
        result = -chebyshev_cos_impl(norm_a);
    } else if (octant == 5) {
        result = -chebyshev_sin_impl(-norm_a);
    } else if (octant == 6) {
        result = chebyshev_sin_impl(norm_a);
    } else if (octant == 7) {
        result = chebyshev_cos_impl(-norm_a);
    }

    return ({{type}}_t){ result };
}
