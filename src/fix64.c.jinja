{#- jinja2 template for fix64.c -#}

{{autogen_comment}}

#include "fix64.h"

#include <stddef.h>
#include <stdint.h>

// Number fractional bits
#define CHEBYSHEV_FRAC_BITS {{chebyshev.frac_bits}}

// Returns the angle as a Q1.62 type, normalised so that 1.0 = pi/4 = 45deg. Angle is always
// measured from the x-axis, returning between -1.0 and 1.0
static inline {{repr.type}}_t norm_angle_chebyshev({{type}}_t angle) {
    // Use this instead of {{type | upper}}_4_PI for accuracy
    const {{repr.type}}_t q0_62_4_pi = {{chebyshev.const(4 / consts.pi)}}; // Q0.62 4/pi

    // Note: 64x64=128 bit multiplication can be done in 1 instruction on x86-64 or 2 on ARM
    // a is now normalised so that 1.0 = pi/4 = 45deg
    int128_t a = (int128_t)angle.repr * q0_62_4_pi; // Q31.94

    return ({{repr.type}}_t)(a >> {{type | upper}}_FRAC_BITS);
}

{% for func in ["sin", "cos", "tan"] %}
{{type}}_t {{type}}_{{func}}_chebyshev({{type}}_t angle) {
    int quadrant = 0;
    {{repr.type}}_t norm_a = norm_angle_chebyshev(angle); // Q1.62

    int64_t sum = 0;

    {{repr.type}}_t a_pow[{{chebyshev[func].coefs | length}}];
    a_pow[0] = INT64_C(1) << CHEBYSHEV_FRAC_BITS;
    for (size_t i = 1; i < sizeof(a_pow)/ sizeof(a_pow[0]); i++) {
        a_pow[i] = ((int128_t)a_pow[i - 1] * norm_a) >> CHEBYSHEV_FRAC_BITS;
    }

{% for coef in chebyshev[func].coefs %}
{% if coef %}
    sum += ((int128_t)a_pow[{{loop.index0}}] * {{chebyshev.const(coef)}}) >> CHEBYSHEV_FRAC_BITS;
{% endif %}
{% endfor %}

    sum += ({{repr.const(1)}} << (CHEBYSHEV_FRAC_BITS - {{type | upper}}_FRAC_BITS - 1)); // rounding
    sum >>= (CHEBYSHEV_FRAC_BITS - {{type | upper}}_FRAC_BITS); // Q32.32

    // return ({{type}}_t){result};
    return ({{type}}_t){sum};
}

{{type}}_t {{type}}_{{func}}({{type}}_t angle) {
    return {{type}}_{{func}}_chebyshev(angle);
}

{% endfor -%}
