{#- jinja2 template for fix64.h -#}

{{autogen_comment}}

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <float.h>
#include <limits.h>
#include <math.h>
#include <stdint.h>

#ifndef __has_builtin
    #define __has_builtin(_) 0
#endif
#if __has_builtin(__builtin_expect_with_probability)
    // Use __builtin_expect_with_probability if available with a probability of 0.9. GCC already
    // uses 0.9 by default for __builtin_expect, but Clang uses 1.0. This makes Clang perform
    // optimisations such as replacing cmov with branches which make the expected case marginally
    // faster while making the other case significantly slower. To get around this we explicitly
    // use 0.9 probability which will reorder branches, etc, but otherwise won't go overboard.
    #define FIX64_LIKELY(cond) __builtin_expect_with_probability((cond), 1, 0.9)
    #define FIX64_UNLIKELY(cond) __builtin_expect_with_probability((cond), 0, 0.9)
#elif __has_builtin(__builtin_expect)
    #define FIX64_LIKELY(cond) __builtin_expect((cond), 1)
    #define FIX64_UNLIKELY(cond) __builtin_expect((cond), 0)
#else
    #define FIX64_LIKELY(cond) (cond)
    #define FIX64_UNLIKELY(cond) (cond)
#endif

#if FLT_RADIX != 2
    #error "FLT_RADIX != 2 not currently supported!"
#endif

// Avoids warnings
#ifdef __SIZEOF_INT128__
    __extension__ typedef __int128 int128_t;
#else
    #error "Unsupported compiler/architecture; no 128-bit integer type defined"
#endif

//==========================================================
// Type definitions
//==========================================================

/// Signed fixed point Q{{int_bits}}.{{frac_bits}} type
typedef struct {
    {{repr.type}}_t repr;
} {{type}}_t;

//==========================================================
// Defines
//==========================================================

/// Number of fractional bits for {{type}}_t
#define {{type | upper}}_FRAC_BITS {{frac_bits}}
/// Number of integral bits for {{type}}_t (excluding sign bit)
#define {{type | upper}}_INT_BITS  {{int_bits}}
/// Number of significant bits for {{type}}_t (excluding sign bit)
#define {{type | upper}}_BITS      ({{type | upper}}_INT_BITS + {{type | upper}}_FRAC_BITS)
/// Maximum value for a {{type}}_t
#define {{type | upper}}_MAX       (({{type}}_t){ {{-repr.type | upper}}_MAX})
/// Minimum value for a {{type}}_t
#define {{type | upper}}_MIN       (({{type}}_t){ {{-repr.type | upper}}_MIN})
/// Smallest positive non-zero value for {{type}}_t
#define {{type | upper}}_EPSILON   (({{type}}_t){ {{-repr.const(1, "d")}}})


//==========================================================
// Literals
//==========================================================

// This function call will be inlined by the compiler, Clang 13 does this even with -Og

/// Creates a {{type}}_t literal, for example {{type | upper}}_C(2.5)
#define {{type | upper}}_C(x) ({{type}}_from_ldbl((long double)(x##L)))

//==========================================================
// Constants
//==========================================================

{% for name, value in nums.items() %}
/// {{type}}_t constant {{value}}
#define {{type | upper}}_{{name | upper}} {{" " * (9 - (name | length))-}}
    (({{type}}_t){ {{-const(value, "x", 9)}}})
{% endfor %}

{% for expr, value in consts.items() %}
/// {{type}}_t mathematical constant {{expr}}
{% set name = expr | replace("_", "") | replace("(", "") | replace(")", "") | replace("/", "_") %}
#define {{type | upper}}_{{name | upper}} {{" " * (9 - (name | length))-}}
    (({{type}}_t){ {{-const(value, "x", 9)}}})
{% endfor %}

//==========================================================
// Generic functions
//==========================================================

// _Generic is only available since C11
#if __STDC_VERSION__ >= 201112L
/// Generic macro to convert a floating point type to {{type}}_t
#define {{type}}_from(x) _Generic((x), \
{% for ftype, fprops in float_types.items() %}
        {{ftype}}: {{type}}_from_{{fprops.short}}, \
{% endfor %}
    )(x)
#endif

//==========================================================
// Conversion functions
//==========================================================

{% for itype, iprops in int_types.items() %}
/// Converts a {{type}}_t to an {{itype}}_t
///
/// @param value the {{type}}_t value to convert
/// @return converted {{itype}} value
static inline {{itype}} {{type}}_to_{{itype}}({{type}}_t value) {
    {{repr.type}}_t result = (value.repr >> {{type | upper}}_FRAC_BITS);
    #if {{repr.type | upper}}_MAX > {{itype | upper}}_MAX
        if (result > {{iprops.short | upper}}_MAX) {
            result = {{iprops.short | upper}}_MAX;
        }
    #endif
    #if defined({{iprops.short | upper}}_MIN) && ({{repr.type | upper}}_MIN > {{itype | upper}}_MIN)
        else if (result < {{iprops.short | upper}}_MIN) {
            result = {{itype | upper}}_MIN;
        }
    #endif
    return ({{itype}})result;
}

{% endfor -%}

{% for itype, iprops in int_types.items() %}
/// Converts an {{itype}} to a {{type}}_t
///
/// @param value the {{itype}} value to convert
/// @return converted {{type}}_t value
static inline {{type}}_t {{type}}_from_{{itype}}({{itype}} value) {
    if (value > ({{type | upper}}_MAX.repr >> {{type | upper}}_FRAC_BITS)) {
        value = ({{type | upper}}_MAX.repr >> {{type | upper}}_FRAC_BITS);
    }
    #if defined({{iprops.short | upper}}_MIN) /* if it's signed */
        else if (value < ({{type | upper}}_MIN.repr >> {{type | upper}}_FRAC_BITS)) {
            value = ({{type | upper}}_MIN.repr >> {{type | upper}}_FRAC_BITS);
        }
    #endif
    return ({{type}}_t){ ({{repr.type}}_t)value << {{type | upper}}_FRAC_BITS };
}

{% endfor -%}

{% for ftype, fprops in float_types.items() %}
/// Converts a {{type}}_t to a {{ftype}}
///
/// @param value the {{type}}_t value to convert
/// @return converted {{ftype}} value
static inline {{ftype}} {{type}}_to_{{fprops.short}}({{type}}_t value) {
    return (({{ftype}})(value.repr) / ({{ftype}})({{repr.const(1)}} << {{type | upper}}_FRAC_BITS));
}

{% endfor -%}

// Note: for (sort-of) efficient float to fixed saturating conversions, we rely on integer limits
// converted to float and rounded towards zero. Unfortunately compilers don't have good support for
// fesetround (GCC for example will reorder fesetround calls relative to float casts). Instead the
// limits are calculated by zeroing the LSBs of the integral max so that has as many significant
// bits as the floating point mantissa. This way the exact value is preserved when casting. The
// min is currently just set as -max since calculating the actual minimum is more tricky. At worst
// we're one interval off, but we can compensate for this by only comparing < min when saturating.
// Values == min are converted as usual so if min is off-by-one the result won't be.

{% for ftype, fprops in float_types.items() %}
/// Converts a {{ftype}} to {{type}}_t
///
/// Saturates if input is outside of {{type}}_t's range. Undefined behaviour if input is NaN
///
/// @param value the {{ftype}} value to convert
/// @return converted {{type}}_t value
static inline {{type}}_t {{type}}_from_{{fprops.short}}({{ftype}} value) {
#if {{fprops.short | upper}}_MANT_DIG >= {{type | upper}}_BITS
    static const {{ftype}} max = {{repr.type | upper}}_MAX;
    static const {{ftype}} min = {{repr.type | upper}}_MIN;
#else
    static const {{ftype}} max = ({{repr.type | upper}}_MAX & ~(({{repr.const(1, "d")}} << {#
        #}({{type | upper}}_BITS - {{fprops.short | upper}}_MANT_DIG)) - 1));
    static const {{ftype}} min = -max;
#endif
{% if ftype == "long double" %}
    // Note: clang fails to optimise out call to exp2l, so we use a bit shift instead. A long
    // double is more than large enough to store the result so the compiler doesn't complain
    // like it does with float (even though float can accurately hold any power of 2 too).
    value = value * ({{repr.const(1)}} << {{type | upper}}_FRAC_BITS);
{% else %}
    value = value * exp2{{fprops.suffix}}({{type | upper}}_FRAC_BITS);
{% endif %}
    value += copysign{{fprops.suffix}}(0.5{{fprops.suffix}}, value);

    {{repr.type}}_t repr;
    if (FIX64_UNLIKELY(value > max)) {
        repr = {{repr.type | upper}}_MAX;
    } else if (FIX64_UNLIKELY(value < min)) {
        repr = {{repr.type | upper}}_MIN;
    } else {
        repr = ({{repr.type}}_t)value;
    }

    return ({{type}}_t){repr};
}

{% endfor -%}

//==========================================================
// Comparison functions
//==========================================================

/// Compares two {{type}}_t values for equality
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if the values are equal, 0 otherwise
static inline int {{type}}_eq({{type}}_t lhs, {{type}}_t rhs) {
    return (lhs.repr == rhs.repr);
}

/// Compares two {{type}}_t values for inequality
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if the values are not equal, 0 otherwise
static inline int {{type}}_neq({{type}}_t lhs, {{type}}_t rhs) {
    return (lhs.repr != rhs.repr);
}

/// Check if a {{type}}_t is less than another
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if lhs is less than rhs, 0 otherwise
static inline int {{type}}_lt({{type}}_t lhs, {{type}}_t rhs) {
    return (lhs.repr < rhs.repr);
}

/// Check if a {{type}}_t is greater than another
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if lhs is greater than rhs, 0 otherwise
static inline int {{type}}_gt({{type}}_t lhs, {{type}}_t rhs) {
    return (lhs.repr > rhs.repr);
}

/// Check if a {{type}}_t is less than or equal to another
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if lhs is less than or equal to rhs, 0 otherwise
static inline int {{type}}_lte({{type}}_t lhs, {{type}}_t rhs) {
    return (lhs.repr <= rhs.repr);
}

/// Check if a {{type}}_t is greater than or equal to another
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if lhs is greater than or equal to rhs, 0 otherwise
static inline int {{type}}_gte({{type}}_t lhs, {{type}}_t rhs) {
    return (lhs.repr >= rhs.repr);
}

//==========================================================
// Arithmetic functions
//==========================================================

/// Negates a {{type}}_t number. Note: {{type}}_neg({{type | upper}}_MIN) returns
/// {{type | upper}}_MAX.
///
/// @param arg number to negate
/// @return the negative of arg
static inline {{type}}_t {{type}}_neg({{type}}_t arg) {
    if (FIX64_UNLIKELY(arg.repr < -{{repr.type | upper}}_MAX)) {
        return {{type | upper}}_MAX;
    }
    return ({{type}}_t){-arg.repr};
}

/// Addition of two {{type}}_t numbers
///
/// @param lhs left hand side for the addition
/// @param rhs right hand side for the addition
/// @return the sum of the two inputs
static inline {{type}}_t {{type}}_add({{type}}_t lhs, {{type}}_t rhs) {
    return ({{type}}_t){lhs.repr + rhs.repr};
}

/// Saturating addition of two {{type}}_t numbers
///
/// @param lhs left hand side for the addition
/// @param rhs right hand side for the addition
/// @return the sum of the two inputs
static inline {{type}}_t {{type}}_add_sat({{type}}_t lhs, {{type}}_t rhs) {
    // TODO add compiler-agnostic version? GCC/Clang currently produce pretty suboptimal signed
    // saturation code for any implementation that doesn't use __builtin_*_overflow
    {{type}}_t result;
    int overflow = __builtin_add_overflow(lhs.repr, rhs.repr, &result.repr);
    if (FIX64_UNLIKELY(overflow)) {
        result = (rhs.repr < 0) ? {{type | upper}}_MIN : {{type | upper}}_MAX;
    }
    return result;
}

/// Subtraction of two {{type}}_t numbers
///
/// @param lhs left hand side for the subtraction
/// @param rhs right hand side for the subtraction
/// @return the difference of the two inputs
static inline {{type}}_t {{type}}_sub({{type}}_t lhs, {{type}}_t rhs) {
    return ({{type}}_t){lhs.repr - rhs.repr};
}

/// Saturating subtraction of two {{type}} numbers
///
/// @param lhs left hand side for the subtraction
/// @param rhs right hand side for the subtraction
/// @return the difference of the two inputs
static inline {{type}}_t {{type}}_sub_sat({{type}}_t lhs, {{type}}_t rhs) {
    // TODO add compiler-agnostic version? GCC/Clang currently produce pretty suboptimal signed
    // saturation code for any implementation that doesn't use __builtin_*_overflow
    {{type}}_t result;
    int overflow = __builtin_sub_overflow(lhs.repr, rhs.repr, &result.repr);
    if (FIX64_UNLIKELY(overflow)) {
        result = (rhs.repr > 0) ? {{type | upper}}_MIN : {{type | upper}}_MAX;
    }
    return result;
}

/// Multiplication of two {{type}}_t numbers
///
/// @param lhs left hand side for the multiplication
/// @param rhs right hand side for the multiplication
/// @return the product of the two inputs
static inline {{type}}_t {{type}}_mul({{type}}_t lhs, {{type}}_t rhs) {
    // TODO don't rely on int128_t?
    int128_t result = ((int128_t)lhs.repr * rhs.repr);
    // add one to the bit below the LSB of the final result for rounding
    result += ({{repr.const(1)}} << ({{type | upper}}_FRAC_BITS - 1));
    result >>= {{type | upper}}_FRAC_BITS;
    return ({{type}}_t){({{repr.type}}_t)result};
}

/// Saturating multiplication of two {{type}}_t numbers
///
/// @param lhs left hand side for the multiplication
/// @param rhs right hand side for the multiplication
/// @return the product of the two inputs
static inline {{type}}_t {{type}}_mul_sat({{type}}_t lhs, {{type}}_t rhs) {
    // TODO don't rely on int128_t?
    int128_t result = ((int128_t)lhs.repr * rhs.repr);
    // add one to the bit below the LSB of the final result for rounding
    result += ({{repr.const(1)}} << ({{type | upper}}_FRAC_BITS - 1));
    result >>= {{type | upper}}_FRAC_BITS;
    if (FIX64_UNLIKELY(result > (int128_t){{repr.type | upper}}_MAX)) {
        result = {{repr.type | upper}}_MAX;
    } else if (FIX64_UNLIKELY(result < (int128_t){{repr.type | upper}}_MIN)) {
        result = {{repr.type | upper}}_MIN;
    }
    return ({{type}}_t){({{repr.type}}_t)result};
}

/// Division of two {{type}}_t numbers. Result is rounded to the nearest representable value
///
/// @param lhs dividend side for the division
/// @param rhs divisor side for the division
/// @return the quotient of the two inputs
static inline {{type}}_t {{type}}_div({{type}}_t lhs, {{type}}_t rhs) {
    // TODO don't rely on int128_t?
    int128_t dividend = ((int128_t)lhs.repr << {{type | upper}}_FRAC_BITS);
    if ((rhs.repr < 0) == (lhs.repr < 0)) {
        dividend += rhs.repr / 2; // if signs are same -> result is positive -> add for rounding
    } else {
        dividend -= rhs.repr / 2; // else subtract for rounding
    }
    int128_t result = dividend / rhs.repr;
    return ({{type}}_t){({{repr.type}}_t)result};
}

/// Saturating division of two {{type}}_t numbers. Result is rounded to the nearest representable
/// value. Division by zero is saturated depending on the sign of the dividend
///
/// @param lhs dividend side for the division
/// @param rhs divisor side for the division
/// @return the quotient of the two inputs
static inline {{type}}_t {{type}}_div_sat({{type}}_t lhs, {{type}}_t rhs) {
    if (FIX64_UNLIKELY(rhs.repr == 0)) {
        return (lhs.repr > 0) ? {{type | upper}}_MAX : {{type | upper}}_MIN;
    }

    // TODO don't rely on int128_t?
    int128_t dividend = ((int128_t)lhs.repr << {{type | upper}}_FRAC_BITS);
    if ((rhs.repr < 0) == (lhs.repr < 0)) {
        dividend += rhs.repr / 2; // if signs are same -> result is positive -> add for rounding
    } else {
        dividend -= rhs.repr / 2; // else subtract for rounding
    }
    int128_t result = dividend / rhs.repr;
    if (FIX64_UNLIKELY(result > (int128_t){{repr.type | upper}}_MAX)) {
        result = {{repr.type | upper}}_MAX;
    } else if (FIX64_UNLIKELY(result < (int128_t){{repr.type | upper}}_MIN)) {
        result = {{repr.type | upper}}_MIN;
    }
    return ({{type}}_t){({{repr.type}}_t)result};
}

//==========================================================
// Basic math functions
//==========================================================

/// Rounds down to the nearest integral value less than or equal to the fixed point argument
///
/// @param arg the fixed point number to floor
/// @return the floor of arg
static inline {{type}}_t {{type}}_floor({{type}}_t arg) {
    return ({{type}}_t){(arg.repr >> {{type | upper}}_FRAC_BITS) << {{type | upper}}_FRAC_BITS};
}

/// Rounds up to the nearest integral value greater than or equal to the fixed point argument
///
/// @param arg the fixed point number to ceil
/// @return the ceil of arg
static inline {{type}}_t {{type}}_ceil({{type}}_t arg) {
    // Add use floor and add (1 - eps) for rounding up
    return {{type}}_floor({{type}}_add(arg, {{type}}_sub({{type | upper}}_ONE, {#
    #}{{type | upper}}_EPSILON)));
}

/// Rounds the fixed point argument to the nearest integral value. Halfway values round away from
/// zero
///
/// @param arg the fixed point number to round
/// @return the rounded value
static inline {{type}}_t {{type}}_round({{type}}_t arg) {
    if ({{type}}_lt(arg, {{type | upper}}_ZERO)) {
        return {{type}}_floor({{type}}_add(arg, {{type}}_sub({{type | upper}}_HALF, {#
            #}{{type | upper}}_EPSILON)));
    } else {
        return {{type}}_floor({{type}}_add(arg, {{type | upper}}_HALF));
    }
}

/// Rounds the fixed point number towards zero
///
/// @param arg the fixed point number to truncate
/// @return the truncated value
static inline {{type}}_t {{type}}_trunc({{type}}_t arg) {
    if ({{type}}_lt(arg, {{type | upper}}_ZERO)) {
        return {{type}}_ceil(arg);
    } else {
        return {{type}}_floor(arg);
    }
}

/// Absolute value of a {{type}}_t number. Note: {{type}}_abs({{type | upper}}_MIN) returns {#
#}{{type | upper}}_MAX.
///
/// @param arg fixed point number
/// @return absolute value of arg
static inline {{type}}_t {{type}}_abs({{type}}_t arg) {
    if ({{type}}_lt(arg, {{type | upper}}_ZERO)) {
        return {{type}}_neg(arg);
    } else {
        return arg;
    }
}

/// Returns the greater of two {{type}}_t numbers
///
/// @param x a fixed point number
/// @param y the other fixed point number
/// @return the greater of x and y
static inline {{type}}_t {{type}}_max({{type}}_t x, {{type}}_t y) {
    return {{type}}_gt(x, y) ? x : y;
}

/// Returns the lesser of two {{type}}_t numbers
///
/// @param x a fixed point number
/// @param y the other fixed point number
/// @return the lesser of x and y
static inline {{type}}_t {{type}}_min({{type}}_t x, {{type}}_t y) {
    return {{type}}_lt(x, y) ? x : y;
}

/// Returns the absolute value of the difference between two numbers. The difference will saturate
/// at {{type | upper}}_MAX
///
/// @param x a fixed point number
/// @param y the other fixed point number
/// @return the absolute difference
static inline {{type}}_t {{type}}_dim({{type}}_t x, {{type}}_t y) {
    return {{type}}_abs({{type}}_sub_sat(x, y));
}

//==========================================================
// Exponential functions
//==========================================================

/// Returns e raised to the given power
///
/// @param arg fixed point number
/// @return e raised to the given power
{{type}}_t {{type}}_exp({{type}}_t arg);

/// Returns 2 raised to the given power
///
/// @param arg fixed point number
/// @return 2 raised to the given power
{{type}}_t {{type}}_exp2({{type}}_t arg);

/// Returns e raised to the given power, minus one
///
/// @param arg fixed point number
/// @return e raised to the given power, minus one
static inline {{type}}_t {{type}}_expm1({{type}}_t arg) {
    return {{type}}_sub({{type}}_exp(arg), {{type | upper}}_ONE);
}

/// Returns natural (base e) logarithm of a number
///
/// @param arg fixed point number
/// @return the natural logarithm
{{type}}_t {{type}}_log({{type}}_t arg);

/// Returns base 10 logarithm of a number
///
/// @param arg fixed point number
/// @return the base 10 logarithm
{{type}}_t {{type}}_log10({{type}}_t arg);

/// Returns base 2 logarithm of a number
///
/// @param arg fixed point number
/// @return the base 2 logarithm
{{type}}_t {{type}}_log2({{type}}_t arg);

/// Returns natural (base e) logarithm of 1 plus the argument
///
/// @param arg fixed point number
/// @return the natural logarithm of 1 plus the argument
static inline {{type}}_t {{type}}_log1p({{type}}_t arg) {
    return {{type}}_log({{type}}_add_sat({{type | upper}}_ONE, arg));
}

//==========================================================
// Power functions
//==========================================================

/// Raises a fixed point number to the power of another
///
/// @param x the base
/// @param y the exponent
/// @return the base raised to the power of the exponent
{{type}}_t {{type}}_pow({{type}}_t x, {{type}}_t y);

/// Calculates a number's square root
///
/// @param arg fixed point number
/// @return the square root
{{type}}_t {{type}}_sqrt({{type}}_t arg);

/// Calculates a number's cube root
///
/// @param arg fixed point number
/// @return the cube root
{{type}}_t {{type}}_cbrt({{type}}_t arg);

/// Calculates the hypotenuse of a right-angled triangle given the two other sides
///
/// @param x one side of the triangle
/// @param y the other side of the triangle
/// @return the length of the hypotenuse
{{type}}_t {{type}}_hypot({{type}}_t x, {{type}}_t y);

//==========================================================
// Trigonometric functions
//==========================================================

/// Computes the sine of a given angle. The result is extremely accurate, with a maximum error of
/// +/-{{type | upper}}_EPSILON for <0.01% of inputs.
///
/// @param angle the angle
/// @return the sine of the angle
{{type}}_t {{type}}_sin({{type}}_t angle);

/// Computes the cosine of a given angle. The result is extremely accurate, with a maximum error of
/// +/-{{type | upper}}_EPSILON for <0.01% of inputs.
///
/// @param angle the angle
/// @return the cosine of the angle
{{type}}_t {{type}}_cos({{type}}_t angle);

/// Computes the tangent of a given angle. The result is extremely accurate, with a maximum error
/// of +/-{{type | upper}}_EPSILON for <0.01% of angles >0.0001pi from a singularity. Near the {#
#}singularities
/// at +/-pi/2 the absolute error increases. The relative error remains small (less than 1e-12).
/// Extremely large results are saturated at {{type | upper}}_MAX or {{type | upper}}_MIN {#
#}depending on the sign.
///
/// @param angle the angle
/// @return the tangent of the angle
{{type}}_t {{type}}_tan({{type}}_t angle);

/// Computes arc sine of a given number
///
/// @param arg fixed point number
/// @return the arc sine
{{type}}_t {{type}}_asin({{type}}_t arg);

/// Computes arc cosine of a given number
///
/// @param arg fixed point number
/// @return the arc cosine
{{type}}_t {{type}}_acos({{type}}_t arg);

/// Computes 2 argument arc tangent of a given pair of numbers
///
/// @param x the horizontal component
/// @param y the vertical component
/// @return the arc tangent of y/x, taking their signs into account
{{type}}_t {{type}}_atan2({{type}}_t x, {{type}}_t y);

/// Computes arc tangent of a given number
///
/// @param arg fixed point number
/// @return the arc tangent
static inline {{type}}_t {{type}}_atan({{type}}_t arg) {
    return {{type}}_atan2(arg, {{type | upper}}_ONE);
}

//==========================================================
// Error and Gamma functions
//==========================================================

/// computes error function
///
/// @param arg a fixed point number
/// @return the result of the error function
{{type}}_t {{type}}_erf({{type}}_t arg);

/// computes complementary error function
///
/// @param arg a fixed point number
/// @return the result of the complementary error function
{{type}}_t {{type}}_erfc({{type}}_t arg);

/// computes gamma function
///
/// @param arg a fixed point number
/// @return the result of the gamma function
{{type}}_t {{type}}_tgamma({{type}}_t arg);

/// computes natural logarithm of the gamma function
///
/// @param arg a fixed point number
/// @return the natural logarithm of the result of the gamma function
{{type}}_t {{type}}_lgamma({{type}}_t arg);

#ifdef __cplusplus
}
#endif
