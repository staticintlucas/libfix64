{#- jinja2 template for fix64.h -#}

{{autogen_comment}}

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <float.h>
#include <limits.h>
#include <math.h>
#include <stddef.h>
#include <stdint.h>

#ifndef __has_builtin
    #define __has_builtin(_) 0
    #define FIX64_DEFINED_HAS_BUILTIN // Used to remember to undefine later
#endif

// GCC < 10 didn't have __has_builtin, so hard code the version
#if __has_builtin(__builtin_expect_with_probability) || (defined(__GNUC__) && __GNUC__ >= 9)
    // Use __builtin_expect_with_probability if available with a probability of 0.9. GCC already
    // uses 0.9 by default for __builtin_expect, but Clang uses 1.0. This makes Clang perform
    // optimisations such as replacing cmov with branches which make the expected case marginally
    // faster while making the other case significantly slower. To get around this we explicitly
    // use 0.9 probability which will reorder branches, etc, but otherwise won't go overboard.
    #define FIX64_LIKELY(cond) __builtin_expect_with_probability((cond), 1, 0.9)
    #define FIX64_UNLIKELY(cond) __builtin_expect_with_probability((cond), 0, 0.9)
#elif __has_builtin(__builtin_expect) || (defined(__GNUC__) && __GNUC__ >= 3)
    #define FIX64_LIKELY(cond) __builtin_expect((cond), 1)
    #define FIX64_UNLIKELY(cond) __builtin_expect((cond), 0)
#else
    #define FIX64_LIKELY(cond) (cond)
    #define FIX64_UNLIKELY(cond) (cond)
#endif

#if FLT_RADIX != 2
    #error "Platforms where FLT_RADIX != 2 are currently not supported!"
#endif
#if (-1 & 3) != 3
    #error "Platforms not using two's complement for signed integers are currently not supported!"
#endif
#if (-1 >> 1) != -1
    #error "Platforms not using arithmetic shifts for signed integers are currently not supported!"
#endif

// Avoids warnings
#ifdef __SIZEOF_INT128__
    __extension__ typedef __int128 fix64_int128_t;
    __extension__ typedef unsigned __int128 fix64_uint128_t;
    #define FIX64_HAVE_INT128
#endif

// GCC < 10 didn't have __has_builtin, so hard code the version
#if __has_builtin(__builtin_add_overflow) || (defined(__GNUC__) && __GNUC__ >= 5)
    static inline int fix64_impl_add_u64_overflow(uint64_t x, uint64_t y, uint64_t *result) {
        return __builtin_add_overflow(x, y, result);
    }
    static inline int fix64_impl_add_i64_overflow(int64_t x, int64_t y, int64_t *result) {
        return __builtin_add_overflow(x, y, result);
    }
    static inline int fix64_impl_sub_u64_underflow(uint64_t x, uint64_t y, uint64_t *result) {
        return __builtin_sub_overflow(x, y, result);
    }
    static inline int fix64_impl_sub_i64_underflow(int64_t x, int64_t y, int64_t *result) {
        return __builtin_sub_overflow(x, y, result);
    }
#else
    static inline int fix64_impl_add_u64_overflow(uint64_t x, uint64_t y, uint64_t *result) {
        *result = x + y;
        return *result < x;
    }
    static inline int fix64_impl_add_i64_overflow(int64_t x, int64_t y, int64_t *result) {
        uint64_t ures = (uint64_t)x + (uint64_t)y; // Avoid UB of signed overflow
        // Avoid UB of unsigned -> signed conversion, gets optimised out on both GCC and Clang
        *result = (ures > INT64_MAX) ? (int64_t)(ures - INT64_MIN) + INT64_MIN : (int64_t)ures;
        // TODO: this is not optimised well by anything
        return ((y > 0) ? (*result < x) : (*result > x));
    }
    static inline int fix64_impl_sub_u64_underflow(uint64_t x, uint64_t y, uint64_t *result) {
        *result = x - y;
        return *result > x;
    }
    static inline int fix64_impl_sub_i64_underflow(int64_t x, int64_t y, int64_t *result) {
        uint64_t ures = (uint64_t)x - (uint64_t)y; // Avoid UB of signed overflow
        // Avoid UB of unsigned -> signed conversion, gets optimised out on both GCC and Clang
        *result = (ures > INT64_MAX) ? (int64_t)(ures - INT64_MIN) + INT64_MIN : (int64_t)ures;
        // TODO: this is not optimised well by anything
        return ((y > 0) ? (*result > x) : (*result < x));
    }
#endif

#ifdef FIX64_HAVE_INT128
    static inline uint64_t fix64_impl_mul_u64_u128(uint64_t x, uint64_t y, uint64_t *hi) {
        fix64_uint128_t res = (fix64_uint128_t)x * y;
        *hi = res >> 64;
        return res;
    }
    static inline uint64_t fix64_impl_mul_i64_i128(int64_t x, int64_t y, int64_t *hi) {
        fix64_int128_t res = (fix64_int128_t)x * y;
        *hi = res >> 64;
        return res;
    }
#else
    static inline uint64_t fix64_impl_mul_u64_u128(uint64_t x, uint64_t y, uint64_t *hi) {
        uint64_t x_hi = x >> 32;
        uint64_t x_lo = (uint32_t)x;
        uint64_t y_hi = y >> 32;
        uint64_t y_lo = (uint32_t)y;

        uint64_t xy_hi = x_hi * y_hi;
        uint64_t xy_md = x_hi * y_lo;
        uint64_t yx_md = y_hi * x_lo;
        uint64_t xy_lo = x_lo * y_lo;

        uint64_t lo;
        int carry0 = fix64_impl_add_u64_overflow(xy_md << 32, yx_md << 32, &lo);
        int carry1 = fix64_impl_add_u64_overflow(lo, xy_lo, &lo);
        *hi = xy_hi + (xy_md >> 32) + (yx_md >> 32) + carry0 + carry1;

        return lo;
    }
    static inline uint64_t fix64_impl_mul_i64_i128(int64_t x, int64_t y, int64_t *hi) {
        uint64_t uhi = (uint64_t)*hi;
        uint64_t lo = fix64_impl_mul_u64_u128((uint64_t)x, (uint64_t)y, &uhi);
        uhi -= (x < 0) ? y : 0;
        uhi -= (y < 0) ? x : 0;
        // Avoid UB of unsigned -> signed conversion, gets optimised out on both GCC and Clang
        *hi = (uhi > INT64_MAX) ? (int64_t)(uhi - INT64_MIN) + INT64_MIN : (int64_t)uhi;
        return lo;
    }
#endif

// Don't try to implement division with fix64_int128_t, it is at best as fast as our C/ASM combo
// implementation, but can be slower
#if defined(__x86_64__) && (defined(__GNUC__) || defined(__clang__) || defined(__INTEL_COMPILER))
    static inline
    uint64_t fix64_impl_div_u128_u64(uint64_t u_hi, uint64_t u_lo, uint64_t v, uint64_t *r) {
        if (FIX64_UNLIKELY(u_hi >= v)) {
            *r = UINT64_MAX;
            return UINT64_MAX;
        }

        uint64_t q;
        __asm__ (
            "divq\t%[v]"
            : "=a"(q), "=d"(*r) // quotient ends up in rax, remainder in rdx
            : [v]"r"(v), "d"(u_hi), "a"(u_lo) // dividend goes in rdx:rax
            : "flags" // divq leaves flags in an undefined state
        );
        return q;
    }

    static inline
    int64_t fix64_impl_div_i128_i64(int64_t u_hi, uint64_t u_lo, int64_t v, int64_t *r) {
        // unsigned variables
        uint64_t uu_hi = u_hi;
        uint64_t uu_lo = u_lo;
        uint64_t uv = v;

        // u_sign = -(u < 0)
        uint64_t u_sign = u_hi >> 63;

        // uu_hi:uu_lo = abs(u_hi:u_lo)
        int overflow = fix64_impl_add_u64_overflow(uu_lo, u_sign, &uu_lo);
        uu_hi += u_sign + overflow;
        uu_lo ^= u_sign;
        uu_hi ^= u_sign;

        uint64_t v_sign = v >> 63; // = -(v < 0)
        uv = (v_sign) ? -uv : uv; // = labs(v);

        uint64_t q_sign = u_sign ^ v_sign; // sign of the quotient

        // handle INT64_MIN as a special case, if u_hi == INT64_MIN (i.e. MSB is set) division will
        // always overflow
        if (FIX64_UNLIKELY(uu_hi >> 63)) {
            *r = (q_sign) ? INT64_MIN : INT64_MAX;
            return (q_sign) ? INT64_MIN : INT64_MAX;
        }

        uint64_t uu_lsh63 = (uu_hi << 1) | (uu_lo >> 63);

        // if v == INT64_MIN (i.e. MSB is set) division will never overflow if (u_hi != INT64_MIN)
        if (!FIX64_UNLIKELY(uv >> 63)) {
            if (q_sign) {
                // u, v both positive => q positive
                // u_max = 0x7fff_ffff * v + (v - 1) => uu < 0x8000_0000 * uv
                // or u, v both negative => q positive
                // u_min = 0x7fff_ffff * v - (-v - 1) => uu < 0x8000_0000 * uv
                if (FIX64_UNLIKELY(uu_lsh63 >= uv)) {
                    *r = INT64_MAX;
                    return INT64_MAX;
                }
            } else {
                // u positive, v negative => q negative
                // u_max = -0x8000_0000 * v + (-v - 1) => uu < 0x8000_0001 * uv
                // or u negative, v positive => q negative
                // u_min = -0x8000_0000 * v - (v - 1) => uu < 0x8000_0001 * uv
                if (FIX64_UNLIKELY(uu_lsh63 > uv || (uu_lsh63 == uv && (uu_lo << 1 >> 1) >= uv))) {
                    *r = INT64_MIN;
                    return INT64_MIN;
                }
            }
        }

        uint64_t q;
        __asm__ (
            "idivq\t%[v]"
            : "=a"(q), "=d"(*r) // quotient ends up in rax, remainder in rdx
            : [v]"r"(v), "d"(u_hi), "a"(u_lo) // dividend goes in rdx:rax
            : "flags" // divq leaves flags in an undefined state
        );
        return q;
    }
#else
    uint64_t fix64_impl_div_u128_u64(uint64_t u_hi, uint64_t u_lo, uint64_t v, uint64_t *r);
    int64_t fix64_impl_div_i128_i64(int64_t u_hi, uint64_t u_lo, int64_t v, int64_t *r);
#endif

//==========================================================
// Type definitions
//==========================================================

/// Signed fixed point Q31.32 type
typedef struct {
    int64_t repr;
} fix64_t;

//==========================================================
// Defines
//==========================================================

/// Number of fractional bits for fix64_t
#define FIX64_FRAC_BITS 32
/// Number of integral bits for fix64_t (excluding sign bit)
#define FIX64_INT_BITS  31
/// Number of significant bits for fix64_t (excluding sign bit)
#define FIX64_BITS      (FIX64_INT_BITS + FIX64_FRAC_BITS)
/// Maximum value for a fix64_t
#define FIX64_MAX       ((fix64_t){INT64_MAX})
/// Minimum value for a fix64_t
#define FIX64_MIN       ((fix64_t){INT64_MIN})
/// Smallest positive non-zero value for fix64_t
#define FIX64_EPSILON   ((fix64_t){INT64_C(1)})

//==========================================================
// Literals
//==========================================================

// This function call will be inlined by the compiler, Clang 13 does this even with -Og

/// Creates a fix64_t literal, for example FIX64_C(2.5)
#define FIX64_C(x) ((fix64_t){ \
    (int64_t)((long double)(x##L) * {{const(consts.one.val)}} + (x##l < 0.L ? -0.5L : 0.5L)) \
})

//==========================================================
// Constants
//==========================================================

{% for name, c in consts.items() %}
/// fix64_t constant {{c.str}}
#define FIX64_{{name | upper}} {{" " * (9 - (name | length))-}}
    ((fix64_t){ {{-const(c.val, digits=9)-}} })
{% endfor %}

//==========================================================
// Generic functions
//==========================================================

// _Generic is only available since C11
#if __STDC_VERSION__ >= 201112L
/// Generic macro to convert a floating point type to fix64_t
#define fix64_from(x) _Generic((x), \
{% for type, i in ints.items() %}
        {{type}}: fix64_from_{{i.short}}, \
{% endfor %}
{% for type, f in floats.items() %}
        {{type}}: fix64_from_{{f.short}}, \
{% endfor %}
    )(x)
#endif

//==========================================================
// Conversion functions
//==========================================================

{% for type, i in ints.items() %}
/// Converts a fix64_t to an {{type}}
///
/// @param value the fix64_t value to convert
/// @return converted {{type}} value
static inline {{type}} fix64_to_{{i.short}}(fix64_t value) {
    int64_t result = (value.repr >> FIX64_FRAC_BITS);
    if (result > {{i.short | upper}}_MAX) {
        result = {{i.short | upper}}_MAX;
    }
{%- if i.signed %} {# -#}
    else if (result < {{i.short | upper}}_MIN) {
        result = {{i.short | upper}}_MIN;
    }
{%- endif +%}
    return result;
}

{% endfor -%}

{% for type, i in ints.items() %}
/// Converts an {{type}} to a fix64_t
///
/// @param value the {{type}} value to convert
/// @return converted fix64_t value
static inline fix64_t fix64_from_{{i.short}}({{type}} value) {
    fix64_t result;
    if (value > (FIX64_MAX.repr >> FIX64_FRAC_BITS)) {
        result = FIX64_MAX;
    }
{%- if i.signed %} {# -#}
    else if (value < (FIX64_MIN.repr >> FIX64_FRAC_BITS)) {
        result = FIX64_MIN;
    }
{%- endif +%}
    else {
        result = (fix64_t){ (int64_t)value << FIX64_FRAC_BITS };
    }
    return result;
}

{% endfor -%}

{% for type, f in floats.items() %}
/// Converts a fix64_t to a {{type}}
///
/// @param value the fix64_t value to convert
/// @return converted {{type}} value
static inline {{type}} fix64_to_{{f.short}}(fix64_t value) {
    return (({{type}})(value.repr) / ({{type}})(INT64_C(1) << FIX64_FRAC_BITS));
}

{% endfor -%}

// Note: for (sort-of) efficient float to fixed saturating conversions, we rely on integer limits
// converted to float and rounded towards zero. Unfortunately compilers don't have good support for
// fesetround (GCC for example will reorder fesetround calls relative to float casts). Instead the
// limits are calculated by zeroing the LSBs of the integral max so that has as many significant
// bits as the floating point mantissa. This way the exact value is preserved when casting.

{% for type, f in floats.items() %}
/// Converts a {{type}} to fix64_t
///
/// Saturates if input is outside of fix64_t's range. Undefined behaviour if input is NaN
///
/// @param value the {{type}} value to convert
/// @return converted fix64_t value
static inline fix64_t fix64_from_{{f.short}}({{type}} value) {
#if {{f.short | upper}}_MANT_DIG >= FIX64_BITS
    static const {{type}} max = INT64_MAX;
    static const {{type}} min = INT64_MIN;
#else
    static const {{type}} max = (INT64_MAX & ~((INT64_C(1) << {#
        #}(FIX64_BITS - {{f.short | upper}}_MANT_DIG)) - 1));
    static const {{type}} min = (INT64_MIN & ~((INT64_C(1) << {#
        #}(FIX64_BITS - {{f.short | upper}}_MANT_DIG)) - 1));
#endif
{% if type == "long double" %}
    // Note: clang fails to optimise out call to exp2l, so we use a bit shift instead. A long
    // double is more than large enough to store the result so the compiler doesn't complain
    // like it does with float (even though float can accurately hold any power of 2 too).
    value = value * (INT64_C(1) << FIX64_FRAC_BITS);
{% else %}
    value = value * exp2{{f.suffix}}(FIX64_FRAC_BITS);
{% endif %}
    value += copysign{{f.suffix}}(0.5{{f.suffix}}, value);

    int64_t repr;
    if (FIX64_UNLIKELY(value > max)) {
        repr = INT64_MAX;
    } else if (FIX64_UNLIKELY(value < min)) {
        repr = INT64_MIN;
    } else {
        repr = (int64_t)value;
    }

    return (fix64_t){repr};
}

{% endfor -%}

//==========================================================
// String conversions
//==========================================================

/// Enum of the possible bases used for formatting fix64_t numbers
enum {
    FIX64_BASE_DECIMAL,     ///< Format as a decimal number
    FIX64_BASE_BINARY,      ///< Format as a binary number
    FIX64_BASE_OCTAL,       ///< Format as an octal number
    FIX64_BASE_HEXADECIMAL, ///< Format as a hexadecimal number
};

/// Struct containing the possible parameters for converting fix64_t numbers to strings
typedef struct {
    /// The number of decimal digits to format. A negative value will format up to a maximum
    /// of -decimals digits while removing trailing zeros. A positive value will leave trailing
    /// zeros intact. A value of 0 will also remove the decimal point.
    int32_t decimals    : 8;
    /// The total width of the number. If the formatted number is smaller than this width, it will
    /// be padded either with spaces or with leading zeros, depending on the value of `pad_0`. The
    /// formatted number will not be truncated if it is larger than width. A value of 0 should be
    /// used when no padding is desired.
    uint32_t width      : 8;
    /// The base for formatting the number given by one of the `FIX64_BASE_*` constants
    uint32_t base       : 2;
    /// If set to 1, the number will be padded with leading zeros when padding is required as
    /// described in the `width` field. If set to 0 the number is padded with leading spaces.
    uint32_t pad_0      : 1;
    /// Whether to add a prefix for the given base. Adds a "0b" prefix for binary, "0o" for octal,
    /// or "0x" for hexadecimal. No prefix is added for decimal. If the `uppercase` field is set,
    /// the base is also in uppercase.
    uint32_t base_pfx   : 1;
    /// Whether to add a "+" prefix when formatting positive numbers
    uint32_t plus_sign  : 1;
    /// Whether to add a leading space when formatting positive numbers. If `plus_sign` is set this
    /// option is ignored.
    uint32_t space_sign : 1;
    /// Whether to format the number in uppercase. This affects extra digits for bases >=10 and
    /// letters in the base prefix if `base_pfx` is set.
    uint32_t uppercase  : 1;
} fix64_fmt_param_t;

/// Converts a fix64_t value to its string representation in the given format. If the buffer is too
/// short the result is truncated. If the destination buffer is NULL or the size is 0 no data is
/// written. The total number of characters that would have been written without truncation is
/// returned. Truncation can be detected by checking:
/// \code
///     if (fix64_to_str_fmt(buf, value, size, fmt) >= size) {
///         // truncation occurred!
///     }
/// \endcode
///
/// @param buf a string buffer to write the string to
/// @param value the fix64_t value to convert
/// @param size the total size of the string buffer used for bounds checking
/// @param fmt the format for the string
/// @return the number of characters that would have been written without truncation
size_t fix64_to_str_fmt(char *buf, fix64_t val, size_t size, fix64_fmt_param_t fmt);

/// Converts a fix64_t value to its string representation. If the buffer is too short the result is
/// truncated. If the destination buffer is NULL or the size is 0 no data is written. The total
/// number of characters that would have been written without truncation is returned. Truncation can
/// be detected by checking:
/// \code
///     if (fix64_to_str(buf, value, size) >= size) {
///         // truncation occurred!
///     }
/// \endcode
///
/// @param buf a string buffer to write the string to
/// @param value the fix64_t value to convert
/// @param size the total size of the string buffer used for bounds checking
/// @return the number of characters that would have been written without truncation
static inline size_t fix64_to_str(char *buf, fix64_t val, size_t size) {
    fix64_fmt_param_t fmt = { .decimals = 5 };
    return fix64_to_str_fmt(buf, val, size, fmt);
}

/// Converts a fix64_t value to its hexadecimal string representation. If the buffer is too short
/// the result is truncated. If the destination buffer is NULL or the size is 0 no data is written.
/// The total number of characters that would have been written without truncation is returned.
/// Truncation can be detected by checking:
/// \code
///     if (fix64_to_hex(buf, value, size) >= size) {
///         // truncation occurred!
///     }
/// \endcode
///
/// @param buf a string buffer to write the string to
/// @param value the fix64_t value to convert
/// @param size the total size of the string buffer used for bounds checking
/// @return the number of characters that would have been written without truncation
static inline size_t fix64_to_hex(char *buf, fix64_t val, size_t size) {
    fix64_fmt_param_t fmt = { .decimals = 4, .base = FIX64_BASE_HEXADECIMAL };
    return fix64_to_str_fmt(buf, val, size, fmt);
}

//==========================================================
// Comparison functions
//==========================================================

/// Compares two fix64_t values for equality
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if the values are equal, 0 otherwise
static inline int fix64_eq(fix64_t lhs, fix64_t rhs) {
    return (lhs.repr == rhs.repr);
}

/// Compares two fix64_t values for inequality
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if the values are not equal, 0 otherwise
static inline int fix64_neq(fix64_t lhs, fix64_t rhs) {
    return (lhs.repr != rhs.repr);
}

/// Check if a fix64_t is less than another
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if lhs is less than rhs, 0 otherwise
static inline int fix64_lt(fix64_t lhs, fix64_t rhs) {
    return (lhs.repr < rhs.repr);
}

/// Check if a fix64_t is greater than another
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if lhs is greater than rhs, 0 otherwise
static inline int fix64_gt(fix64_t lhs, fix64_t rhs) {
    return (lhs.repr > rhs.repr);
}

/// Check if a fix64_t is less than or equal to another
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if lhs is less than or equal to rhs, 0 otherwise
static inline int fix64_lte(fix64_t lhs, fix64_t rhs) {
    return (lhs.repr <= rhs.repr);
}

/// Check if a fix64_t is greater than or equal to another
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if lhs is greater than or equal to rhs, 0 otherwise
static inline int fix64_gte(fix64_t lhs, fix64_t rhs) {
    return (lhs.repr >= rhs.repr);
}

//==========================================================
// Arithmetic functions
//==========================================================

/// Negates a fix64_t number. Note: fix64_neg(FIX64_MIN) returns
/// FIX64_MAX.
///
/// @param arg number to negate
/// @return the negative of arg
static inline fix64_t fix64_neg(fix64_t arg) {
    if (FIX64_UNLIKELY(arg.repr < -INT64_MAX)) {
        return FIX64_MAX;
    }
    return (fix64_t){-arg.repr};
}

/// Addition of two fix64_t numbers
///
/// @param lhs left hand side for the addition
/// @param rhs right hand side for the addition
/// @return the sum of the two inputs
static inline fix64_t fix64_add(fix64_t lhs, fix64_t rhs) {
    return (fix64_t){lhs.repr + rhs.repr};
}

/// Saturating addition of two fix64_t numbers
///
/// @param lhs left hand side for the addition
/// @param rhs right hand side for the addition
/// @return the sum of the two inputs
static inline fix64_t fix64_add_sat(fix64_t lhs, fix64_t rhs) {
    // TODO add compiler-agnostic version? GCC/Clang currently produce pretty suboptimal signed
    // saturation code for any implementation that doesn't use __builtin_*_overflow
    fix64_t result;
    int overflow = __builtin_add_overflow(lhs.repr, rhs.repr, &result.repr);
    if (FIX64_UNLIKELY(overflow)) {
        result = (rhs.repr < 0) ? FIX64_MIN : FIX64_MAX;
    }
    return result;
}

/// Subtraction of two fix64_t numbers
///
/// @param lhs left hand side for the subtraction
/// @param rhs right hand side for the subtraction
/// @return the difference of the two inputs
static inline fix64_t fix64_sub(fix64_t lhs, fix64_t rhs) {
    return (fix64_t){lhs.repr - rhs.repr};
}

/// Saturating subtraction of two fix64 numbers
///
/// @param lhs left hand side for the subtraction
/// @param rhs right hand side for the subtraction
/// @return the difference of the two inputs
static inline fix64_t fix64_sub_sat(fix64_t lhs, fix64_t rhs) {
    // TODO add compiler-agnostic version? GCC/Clang currently produce pretty suboptimal signed
    // saturation code for any implementation that doesn't use __builtin_*_overflow
    fix64_t result;
    int overflow = __builtin_sub_overflow(lhs.repr, rhs.repr, &result.repr);
    if (FIX64_UNLIKELY(overflow)) {
        result = (rhs.repr > 0) ? FIX64_MIN : FIX64_MAX;
    }
    return result;
}

/// Multiplication of two fix64_t numbers
///
/// @param lhs left hand side for the multiplication
/// @param rhs right hand side for the multiplication
/// @return the product of the two inputs
static inline fix64_t fix64_mul(fix64_t lhs, fix64_t rhs) {
    int64_t hi;
    uint64_t lo = fix64_impl_mul_i64_i128(lhs.repr, rhs.repr, &hi);
    hi += fix64_impl_add_u64_overflow(lo, (INT64_C(1) << (FIX64_FRAC_BITS - 1)), &lo); // For rounding
    int64_t result = (hi << (64 - FIX64_FRAC_BITS)) | (lo >> FIX64_FRAC_BITS);
    return (fix64_t){ result };
}

/// Saturating multiplication of two fix64_t numbers
///
/// @param lhs left hand side for the multiplication
/// @param rhs right hand side for the multiplication
/// @return the product of the two inputs
static inline fix64_t fix64_mul_sat(fix64_t lhs, fix64_t rhs) {
    int64_t hi;
    uint64_t lo = fix64_impl_mul_i64_i128(lhs.repr, rhs.repr, &hi);
    hi += fix64_impl_add_u64_overflow(lo, (INT64_C(1) << (FIX64_FRAC_BITS - 1)), &lo); // For rounding
    int64_t result = (hi << (64 - FIX64_FRAC_BITS)) | (lo >> FIX64_FRAC_BITS);
    if (FIX64_UNLIKELY(hi > (FIX64_MAX.repr >> FIX64_FRAC_BITS))) {
        result = FIX64_MAX.repr;
    } else if (FIX64_UNLIKELY(hi < (FIX64_MIN.repr >> FIX64_FRAC_BITS))) {
        result = FIX64_MIN.repr;
    }
    return (fix64_t){ result };
}

/// Division of two fix64_t numbers. Result is rounded to the nearest representable value
///
/// @param lhs dividend side for the division
/// @param rhs divisor side for the division
/// @return the quotient of the two inputs
static inline fix64_t fix64_div(fix64_t lhs, fix64_t rhs) {
    int64_t hi = lhs.repr >> (64 - FIX64_FRAC_BITS);
    uint64_t lo = (uint64_t)lhs.repr << FIX64_FRAC_BITS;

    if ((rhs.repr < 0) == (lhs.repr < 0)) {
        // if signs are same -> result is positive -> add for rounding
        hi += fix64_impl_add_u64_overflow(lo, rhs.repr / 2, &lo);
    } else {
        // else subtract for rounding
        hi -= fix64_impl_sub_u64_underflow(lo, rhs.repr / 2, &lo);
    }

    // fix64_impl_div_i128_i64 already saturates for us
    // TODO do we manually implement wrapping logic? What advantage does the non-saturating function
    // have if it has to implement extra logic to not saturate?
    int64_t rem;
    int64_t result = fix64_impl_div_i128_i64(hi, lo, rhs.repr, &rem);

    return (fix64_t){(int64_t)result};
}

/// Saturating division of two fix64_t numbers. Result is rounded to the nearest representable
/// value. Division by zero is saturated depending on the sign of the dividend
///
/// @param lhs dividend side for the division
/// @param rhs divisor side for the division
/// @return the quotient of the two inputs
static inline fix64_t fix64_div_sat(fix64_t lhs, fix64_t rhs) {
    int64_t hi = lhs.repr >> (64 - FIX64_FRAC_BITS);
    uint64_t lo = (uint64_t)lhs.repr << FIX64_FRAC_BITS;

    if ((rhs.repr < 0) == (lhs.repr < 0)) {
        // if signs are same -> result is positive -> add for rounding
        hi += fix64_impl_add_u64_overflow(lo, rhs.repr / 2, &lo);
    } else {
        // else subtract for rounding
        hi -= fix64_impl_sub_u64_underflow(lo, rhs.repr / 2, &lo);
    }

    // fix64_impl_div_i128_i64 already saturates for us
    int64_t rem;
    int64_t result = fix64_impl_div_i128_i64(hi, lo, rhs.repr, &rem);

    return (fix64_t){(int64_t)result};
}

//==========================================================
// Basic math functions
//==========================================================

/// Rounds down to the nearest integral value less than or equal to the fixed point argument
///
/// @param arg the fixed point number to floor
/// @return the floor of arg
static inline fix64_t fix64_floor(fix64_t arg) {
    return (fix64_t){(arg.repr >> FIX64_FRAC_BITS) << FIX64_FRAC_BITS};
}

/// Rounds up to the nearest integral value greater than or equal to the fixed point argument
///
/// @param arg the fixed point number to ceil
/// @return the ceil of arg
static inline fix64_t fix64_ceil(fix64_t arg) {
    // Add use floor and add (1 - eps) for rounding up
    return fix64_floor(fix64_add(arg, fix64_sub(FIX64_ONE, FIX64_EPSILON)));
}

/// Rounds the fixed point argument to the nearest integral value. Halfway values round away from
/// zero
///
/// @param arg the fixed point number to round
/// @return the rounded value
static inline fix64_t fix64_round(fix64_t arg) {
    if (fix64_lt(arg, FIX64_ZERO)) {
        return fix64_floor(fix64_add(arg, fix64_sub(FIX64_HALF, FIX64_EPSILON)));
    } else {
        return fix64_floor(fix64_add(arg, FIX64_HALF));
    }
}

/// Rounds the fixed point number towards zero
///
/// @param arg the fixed point number to truncate
/// @return the truncated value
static inline fix64_t fix64_trunc(fix64_t arg) {
    if (fix64_lt(arg, FIX64_ZERO)) {
        return fix64_ceil(arg);
    } else {
        return fix64_floor(arg);
    }
}

/// Absolute value of a fix64_t number. Note: fix64_abs(FIX64_MIN) returns FIX64_MAX.
///
/// @param arg fixed point number
/// @return absolute value of arg
static inline fix64_t fix64_abs(fix64_t arg) {
    if (fix64_lt(arg, FIX64_ZERO)) {
        return fix64_neg(arg);
    } else {
        return arg;
    }
}

/// Returns the greater of two fix64_t numbers
///
/// @param x a fixed point number
/// @param y the other fixed point number
/// @return the greater of x and y
static inline fix64_t fix64_max(fix64_t x, fix64_t y) {
    return fix64_gt(x, y) ? x : y;
}

/// Returns the lesser of two fix64_t numbers
///
/// @param x a fixed point number
/// @param y the other fixed point number
/// @return the lesser of x and y
static inline fix64_t fix64_min(fix64_t x, fix64_t y) {
    return fix64_lt(x, y) ? x : y;
}

/// Returns the absolute value of the difference between two numbers. The difference will saturate
/// at FIX64_MAX
///
/// @param x a fixed point number
/// @param y the other fixed point number
/// @return the absolute difference
static inline fix64_t fix64_dim(fix64_t x, fix64_t y) {
    return fix64_abs(fix64_sub_sat(x, y));
}

//==========================================================
// Exponential functions
//==========================================================

/// Returns e raised to the given power
///
/// @param arg fixed point number
/// @return e raised to the given power
fix64_t fix64_exp(fix64_t arg);

/// Returns 2 raised to the given power
///
/// @param arg fixed point number
/// @return 2 raised to the given power
fix64_t fix64_exp2(fix64_t arg);

/// Returns e raised to the given power, minus one
///
/// @param arg fixed point number
/// @return e raised to the given power, minus one
static inline fix64_t fix64_expm1(fix64_t arg) {
    return fix64_sub(fix64_exp(arg), FIX64_ONE);
}

/// Returns natural (base e) logarithm of a number
///
/// @param arg fixed point number
/// @return the natural logarithm
fix64_t fix64_log(fix64_t arg);

/// Returns base 10 logarithm of a number
///
/// @param arg fixed point number
/// @return the base 10 logarithm
fix64_t fix64_log10(fix64_t arg);

/// Returns base 2 logarithm of a number
///
/// @param arg fixed point number
/// @return the base 2 logarithm
fix64_t fix64_log2(fix64_t arg);

/// Returns natural (base e) logarithm of 1 plus the argument
///
/// @param arg fixed point number
/// @return the natural logarithm of 1 plus the argument
static inline fix64_t fix64_log1p(fix64_t arg) {
    return fix64_log(fix64_add_sat(FIX64_ONE, arg));
}

//==========================================================
// Power functions
//==========================================================

/// Raises a fixed point number to the power of another
///
/// @param x the base
/// @param y the exponent
/// @return the base raised to the power of the exponent
static inline fix64_t fix64_pow(fix64_t x, fix64_t y) {
    // TODO do this at higher precision?
    return fix64_exp2(fix64_mul_sat(y, fix64_log2(x)));
}

/// Calculates a number's square root
///
/// @param arg fixed point number
/// @return the square root
static inline fix64_t fix64_sqrt(fix64_t arg) {
    // TODO do this at higher precision?
    return fix64_pow(arg, FIX64_HALF);
}

/// Calculates a number's cube root
///
/// @param arg fixed point number
/// @return the cube root
static inline fix64_t fix64_cbrt(fix64_t arg) {
    // TODO do this at higher precision?
    return fix64_pow(arg, (fix64_t){ {{-const(consts.one.val / 3)-}} });
}

/// Calculates the hypotenuse of a right-angled triangle given the two other sides
///
/// @param x one side of the triangle
/// @param y the other side of the triangle
/// @return the length of the hypotenuse
static inline fix64_t fix64_hypot(fix64_t x, fix64_t y) {
    // TODO do this at higher precision?
    return fix64_sqrt(fix64_add_sat(fix64_mul_sat(x, x), fix64_mul_sat(y, y)));
}

//==========================================================
// Trigonometric functions
//==========================================================

/// Computes the sine of a given angle. The result is extremely accurate, with a maximum error of
/// +/-FIX64_EPSILON for <0.01% of inputs.
///
/// @param angle the angle
/// @return the sine of the angle
fix64_t fix64_sin(fix64_t angle);

/// Computes the cosine of a given angle. The result is extremely accurate, with a maximum error of
/// +/-FIX64_EPSILON for <0.01% of inputs.
///
/// @param angle the angle
/// @return the cosine of the angle
fix64_t fix64_cos(fix64_t angle);

/// Computes the tangent of a given angle. The result is extremely accurate, with a maximum error
/// of +/-FIX64_EPSILON for <0.01% of angles >0.0001pi from a singularity. Near the singularities
/// at +/-pi/2 the absolute error increases. The relative error remains small (less than 1e-12).
/// Extremely large results are saturated at FIX64_MAX or FIX64_MIN depending on the sign.
///
/// @param angle the angle
/// @return the tangent of the angle
fix64_t fix64_tan(fix64_t angle);

/// Computes arc sine of a given number
///
/// @param arg fixed point number
/// @return the arc sine
fix64_t fix64_asin(fix64_t arg);

/// Computes arc cosine of a given number
///
/// @param arg fixed point number
/// @return the arc cosine
fix64_t fix64_acos(fix64_t arg);

/// Computes 2 argument arc tangent of a given pair of numbers
///
/// @param x the horizontal component
/// @param y the vertical component
/// @return the arc tangent of y/x, taking their signs into account
fix64_t fix64_atan2(fix64_t x, fix64_t y);

/// Computes arc tangent of a given number
///
/// @param arg fixed point number
/// @return the arc tangent
static inline fix64_t fix64_atan(fix64_t arg) {
    return fix64_atan2(arg, FIX64_ONE);
}

//==========================================================
// Error and Gamma functions
//==========================================================

/// computes error function
///
/// @param arg a fixed point number
/// @return the result of the error function
fix64_t fix64_erf(fix64_t arg);

/// computes complementary error function
///
/// @param arg a fixed point number
/// @return the result of the complementary error function
fix64_t fix64_erfc(fix64_t arg);

/// computes gamma function
///
/// @param arg a fixed point number
/// @return the result of the gamma function
fix64_t fix64_tgamma(fix64_t arg);

/// computes natural logarithm of the gamma function
///
/// @param arg a fixed point number
/// @return the natural logarithm of the result of the gamma function
fix64_t fix64_lgamma(fix64_t arg);

// Clean up defines if used as a public header
#ifndef FIX64_INTERNAL
    #ifdef FIX64_DEFINED_HAS_BUILTIN
        #undef __has_builtin
        #undef FIX64_DEFINED_HAS_BUILTIN
    #endif

    #undef FIX64_LIKELY
    #undef FIX64_UNLIKELY
#endif

#ifdef __cplusplus
}
#endif
