{#- jinja2 template for fix64.h -#}

{{autogen_comment}}

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <float.h>
#include <math.h>
#include <stdint.h>

#ifndef __has_builtin
    #define __has_builtin(_) 0
#endif
#if __has_builtin(__builtin_expect_with_probability)
    // Use probability of 0.9 - this is high enough that clang will reorder branches, etc. but it
    // won't use branches instead of cmov instructions (it does this with probability >0.99, default
    // for __builtin_expect seems to be 1.0). GCC uses default of probability of 0.9 and uses cmov
    // anyway regardless of probability
    #define FIX64_LIKELY(cond) __builtin_expect_with_probability((cond), 1, 0.9)
    #define FIX64_UNLIKELY(cond) __builtin_expect_with_probability((cond), 0, 0.9)
#elif __has_builtin(__builtin_expect)
    #define FIX64_LIKELY(cond) __builtin_expect((cond), 1)
    #define FIX64_UNLIKELY(cond) __builtin_expect((cond), 0)
#else
    #define FIX64_LIKELY(cond) (cond)
    #define FIX64_UNLIKELY(cond) (cond)
#endif

#if FLT_RADIX != 2
    #error "FLT_RADIX != 2 not currently supported!"
#endif

// Avoids warnings
#ifdef __SIZEOF_INT128__
    __extension__ typedef __int128 int128_t;
#else
    #error "Unsupported compiler/architecture; no 128-bit integer type defined"
#endif

//==========================================================
// Type definitions
//==========================================================

/// Signed fixed point Q{{int_bits}}.{{frac_bits}} type
typedef struct {
    {{repr.name}} repr;
} {{type}};

//==========================================================
// Defines
//==========================================================

/// Number of fractional bits for {{type}}
#define {{macro}}_FRAC_BITS {{frac_bits}}
/// Number of integral bits for {{type}} (excluding sign bit)
#define {{macro}}_INT_BITS  {{int_bits}}
/// Number of significant bits for {{type}} (excluding sign bit)
#define {{macro}}_BITS      ({{macro}}_INT_BITS + {{macro}}_FRAC_BITS)
/// Maximum value for a {{type}}
#define {{macro}}_MAX       (({{type}}){ {{-repr.max-}} })
/// Minimum value for a {{type}}
#define {{macro}}_MIN       (({{type}}){ {{-repr.min-}} })
/// Smallest positive non-zero value for {{type}}
#define {{macro}}_EPSILON   (({{type}}){1})

//==========================================================
// Literals
//==========================================================

// This function call will be inlined by the compiler, Clang 13 does this even with -Og

/// Creates a {{type}} literal, for example {{macro}}_C(2.5)
#define {{macro}}_C(x) ({{prefix}}_from_ldbl((long double)(x##L)))

//==========================================================
// Constants
//==========================================================

{% for name, num in nums.items() %}
/// {{type}} constant value {{num.string}}
#define {{macro}}_{{name | upper}} {{ " " * (4 - (name | length)) -}}
    (({{type}}){ {{-repr.const("0x%09x" | format(tofix(num.value)))}}})
{% endfor %}

{% for name, const in consts.items() %}
/// {{type}} mathematical constant {{const.string}}
#define {{macro}}_{{name | upper}} {{ " " * (8 - (name | length)) -}}
    (({{type}}){ {{-repr.const("0x%09x" | format(tofix(const.value)))}}})
{% endfor %}

//==========================================================
// Generic functions
//==========================================================

// _Generic is only available since C11
#if __STDC_VERSION__ >= 201112L
/// Generic macro to convert a floating point type to {{type}}
#define {{prefix}}_from(x) _Generic((x), \
{% for name, float in floats.items() %}
        {{name}}: {{prefix}}_from_{{float.prefix}}, \
{% endfor %}
    )(x)
#endif

//==========================================================
// Conversion functions
//==========================================================

{% for name, float in floats.items() %}
/// Converts a {{type}} to {{name}}
///
/// @param value the {{type}} value to convert
/// @return converted {{name}} value
static inline {{name}} {{prefix}}_to_{{float.prefix}}({{type}} value) {
    return (({{name}})(value.repr) / ({{name}})({{repr.const(1)}} << {{macro}}_FRAC_BITS));
}

{% endfor -%}

// Note: for (sort-of) efficient saturating floating point to fixed conversions, we rely on integer
// type limits converted to float and rounded towards zero. These are used instead of fesetround()
// since certain compilers (GCC for example) will reorder float casts so it may well not be between
// a pair of fesetround calls. The limits are set by zeroing the LSBs so that the integral max has
// only as many significant bits as the floating point mantissa so the exact value is preserved when
// casting. The signed min values are just the negative of the max since calculating the actual
// minimum is pretty tricky. At worst we're one interval off, so we can compensate for this by only
// comparing < min; values == min are converted as usual so if min is off by one the results still
// won't be affected.

{% for name, float in floats.items() %}
/// Converts a {{name}} to {{type}}
///
/// Saturates if input is outside of {{type}}'s range. Undefined behaviour if input is NaN
///
/// @param value the {{name}} value to convert
/// @return converted {{type}} value
static inline {{type}} {{prefix}}_from_{{float.prefix}}({{name}} value) {
#if {{float.macro}}_MANT_DIG >= ({{macro}}_BITS)
    static const {{name}} max = {{repr.max}};
    static const {{name}} min = {{repr.min}};
#else
    static const {{name}} max = ({{repr.max}} & {#
        #}~(({{repr.const(1)}} << ({{macro}}_BITS - {{float.macro}}_MANT_DIG)) - 1));
    static const {{name}} min = -max;
#endif
{% if name == "long double" %}
    // Note: clang fails to optimise out call to exp2l, so we use a bit shift instead. A long
    // double is more than large enough to store the result so the compiler doesn't complain
    // like it does with float (even though float can accurately hold any power of 2 too).
    value = value * ({{repr.const(1)}} << {{macro}}_FRAC_BITS);
{% else %}
    value = value * exp2{{float.suffix}}({{macro}}_FRAC_BITS);
{% endif %}
    value += copysign{{float.suffix}}(0.5{{float.suffix}}, value);

    {{repr.name}} repr;
    if (FIX64_UNLIKELY(value > max)) {
        repr = {{repr.max}};
    } else if (FIX64_UNLIKELY(value < min)) {
        repr = {{repr.min}};
    } else {
        repr = ({{repr.name}})value;
    }

    return ({{type}}){repr};
}

{% endfor -%}

//==========================================================
// Comparison functions
//==========================================================

/// Compares two {{type}} values for equality
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if the values are equal, 0 otherwise
static inline int {{prefix}}_eq({{type}} lhs, {{type}} rhs) {
    return (lhs.repr == rhs.repr);
}

/// Compares two {{type}} values for inequality
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if the values are not equal, 0 otherwise
static inline int {{prefix}}_neq({{type}} lhs, {{type}} rhs) {
    return (lhs.repr != rhs.repr);
}

/// Check if a {{type}} is less than another
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if lhs is less than rhs, 0 otherwise
static inline int {{prefix}}_lt({{type}} lhs, {{type}} rhs) {
    return (lhs.repr < rhs.repr);
}

/// Check if a {{type}} is greater than another
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if lhs is greater than rhs, 0 otherwise
static inline int {{prefix}}_gt({{type}} lhs, {{type}} rhs) {
    return (lhs.repr > rhs.repr);
}

/// Check if a {{type}} is less than or equal to another
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if lhs is less than or equal to rhs, 0 otherwise
static inline int {{prefix}}_lte({{type}} lhs, {{type}} rhs) {
    return (lhs.repr <= rhs.repr);
}

/// Check if a {{type}} is greater than or equal to another
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if lhs is greater than or equal to rhs, 0 otherwise
static inline int {{prefix}}_gte({{type}} lhs, {{type}} rhs) {
    return (lhs.repr >= rhs.repr);
}

//==========================================================
// Arithmetic functions
//==========================================================

/// Negates a {{type}} number. Note: {{prefix}}_neg({{macro}}_MIN) returns
/// {{macro}}_MAX.
///
/// @param arg number to negate
/// @return the negative of arg
static inline {{type}} {{prefix}}_neg({{type}} arg) {
    if (FIX64_UNLIKELY(arg.repr < -{{repr.max}})) {
        return {{macro}}_MAX;
    }
    return ({{type}}){-arg.repr};
}

/// Addition of two {{type}} numbers
///
/// @param lhs left hand side for the addition
/// @param rhs right hand side for the addition
/// @return the sum of the two inputs
static inline {{type}} {{prefix}}_add({{type}} lhs, {{type}} rhs) {
    return ({{type}}){lhs.repr + rhs.repr};
}

/// Saturating addition of two {{type}} numbers
///
/// @param lhs left hand side for the addition
/// @param rhs right hand side for the addition
/// @return the sum of the two inputs
static inline {{type}} {{prefix}}_add_sat({{type}} lhs, {{type}} rhs) {
    // TODO add compiler-agnostic version? GCC/Clang currently produce pretty suboptimal signed
    // saturation code for any implementation that doesn't use __builtin_*_overflow
    {{repr.name}} result;
    int overflow = __builtin_add_overflow(lhs.repr, rhs.repr, &result);
    if (FIX64_UNLIKELY(overflow)) {
        result = (rhs.repr < 0) ? {{repr.min}} : {{repr.max}};
    }
    return ({{type}}){result};
}

/// Subtraction of two {{type}} numbers
///
/// @param lhs left hand side for the subtraction
/// @param rhs right hand side for the subtraction
/// @return the difference of the two inputs
static inline {{type}} {{prefix}}_sub({{type}} lhs, {{type}} rhs) {
    return ({{type}}){lhs.repr - rhs.repr};
}

/// Saturating subtraction of two {{type}} numbers
///
/// @param lhs left hand side for the subtraction
/// @param rhs right hand side for the subtraction
/// @return the difference of the two inputs
static inline {{type}} {{prefix}}_sub_sat({{type}} lhs, {{type}} rhs) {
    // TODO add compiler-agnostic version? GCC/Clang currently produce pretty suboptimal signed
    // saturation code for any implementation that doesn't use __builtin_*_overflow
    {{repr.name}} result;
    int overflow = __builtin_sub_overflow(lhs.repr, rhs.repr, &result);
    if (FIX64_UNLIKELY(overflow)) {
        result = (rhs.repr > 0) ? {{repr.min}} : {{repr.max}};
    }
    return ({{type}}){result};
}

/// Multiplication of two {{type}} numbers
///
/// @param lhs left hand side for the multiplication
/// @param rhs right hand side for the multiplication
/// @return the product of the two inputs
static inline {{type}} {{prefix}}_mul({{type}} lhs, {{type}} rhs) {
    // TODO don't rely on int128_t?
    int128_t result = ((int128_t)lhs.repr * rhs.repr);
    // add to the most significant of the bits that will be shifted away for rounding
    result += ({{repr.const(1)}} << ({{macro}}_FRAC_BITS - 1));
    result >>= {{macro}}_FRAC_BITS;
    return ({{type}}){({{repr.name}})result};
}

/// Saturating multiplication of two {{type}} numbers
///
/// @param lhs left hand side for the multiplication
/// @param rhs right hand side for the multiplication
/// @return the product of the two inputs
static inline {{type}} {{prefix}}_mul_sat({{type}} lhs, {{type}} rhs) {
    // TODO don't rely on int128_t?
    int128_t result = ((int128_t)lhs.repr * rhs.repr);
    // add to the most significant of the bits that will be shifted away for rounding
    result += ({{repr.const(1)}} << ({{macro}}_FRAC_BITS - 1));
    result >>= {{macro}}_FRAC_BITS;
    if (FIX64_UNLIKELY(result > (int128_t){{repr.max}})) {
        result = {{repr.max}};
    } else if (FIX64_UNLIKELY(result < (int128_t){{repr.min}})) {
        result = {{repr.min}};
    }
    return ({{type}}){({{repr.name}})result};
}

/// Division of two {{type}} numbers. Result is rounded to the nearest representable value
///
/// @param lhs dividend side for the division
/// @param rhs divisor side for the division
/// @return the quotient of the two inputs
static inline {{type}} {{prefix}}_div({{type}} lhs, {{type}} rhs) {
    // TODO don't rely on int128_t?
    int128_t dividend = ((int128_t)lhs.repr << {{macro}}_FRAC_BITS);
    if ((rhs.repr < 0) == (lhs.repr < 0)) {
        dividend += rhs.repr / 2; // if signs are same -> result is positive -> add for rounding
    } else {
        dividend -= rhs.repr / 2; // else subtract for rounding
    }
    int128_t result = dividend / rhs.repr;
    return ({{type}}){({{repr.name}})result};
}

/// Saturating division of two {{type}} numbers. Result is rounded to the nearest representable
/// value. Division by zero is saturated depending on the sign of the dividend
///
/// @param lhs dividend side for the division
/// @param rhs divisor side for the division
/// @return the quotient of the two inputs
static inline {{type}} {{prefix}}_div_sat({{type}} lhs, {{type}} rhs) {
    if (FIX64_UNLIKELY(rhs.repr == 0)) {
        return (lhs.repr > 0) ? {{macro}}_MAX : {{macro}}_MIN;
    }

    // TODO don't rely on int128_t?
    int128_t dividend = ((int128_t)lhs.repr << {{macro}}_FRAC_BITS);
    if ((rhs.repr < 0) == (lhs.repr < 0)) {
        dividend += rhs.repr / 2; // if signs are same -> result is positive -> add for rounding
    } else {
        dividend -= rhs.repr / 2; // else subtract for rounding
    }
    int128_t result = dividend / rhs.repr;
    if (FIX64_UNLIKELY(result > (int128_t){{repr.max}})) {
        result = {{repr.max}};
    } else if (FIX64_UNLIKELY(result < (int128_t){{repr.min}})) {
        result = {{repr.min}};
    }
    return ({{type}}){({{repr.name}})result};
}

//==========================================================
// Basic math functions
//==========================================================

/// Rounds down to the nearest integral value less than or equal to the fixed point argument
///
/// @param arg the fixed point number to floor
/// @return the floor of arg
static inline {{type}} {{prefix}}_floor({{type}} arg) {
    return ({{type}}){(arg.repr >> {{macro}}_FRAC_BITS) << {{macro}}_FRAC_BITS};
}

/// Rounds up to the nearest integral value greater than or equal to the fixed point argument
///
/// @param arg the fixed point number to ceil
/// @return the ceil of arg
static inline {{type}} {{prefix}}_ceil({{type}} arg) {
    // Add use floor and add (1 - eps) for rounding up
    return {{prefix}}_floor({{prefix}}_add(arg, {{prefix}}_sub({{macro}}_ONE, {{macro}}_EPSILON)));
}

/// Rounds the fixed point argument to the nearest integral value. Halfway values round away from
/// zero
///
/// @param arg the fixed point number to round
/// @return the rounded value
static inline {{type}} {{prefix}}_round({{type}} arg) {
    if ({{prefix}}_lt(arg, {{macro}}_ZERO)) {
        return {{prefix}}_floor({{prefix}}_add(arg, {{prefix}}_sub({{macro}}_HALF, {{macro}}_EPSILON)));
    } else {
        return {{prefix}}_floor({{prefix}}_add(arg, {{macro}}_HALF));
    }
}

/// Rounds the fixed point number towards zero
///
/// @param arg the fixed point number to truncate
/// @return the truncated value
static inline {{type}} {{prefix}}_trunc({{type}} arg) {
    if ({{prefix}}_lt(arg, {{macro}}_ZERO)) {
        return {{prefix}}_ceil(arg);
    } else {
        return {{prefix}}_floor(arg);
    }
}

/// Absolute value of a {{type}} number. Note: {{prefix}}_abs({{macro}}_MIN)
/// returns {{macro}}_MAX.
///
/// @param arg fixed point number
/// @return absolute value of arg
static inline {{type}} {{prefix}}_abs({{type}} arg) {
    if ({{prefix}}_lt(arg, {{macro}}_ZERO)) {
        return {{prefix}}_neg(arg);
    } else {
        return arg;
    }
}

/// Returns the greater of two {{type}} numbers
///
/// @param x a fixed point number
/// @param y the other fixed point number
/// @return the greater of x and y
static inline {{type}} {{prefix}}_max({{type}} x, {{type}} y) {
    return {{prefix}}_gt(x, y) ? x : y;
}

/// Returns the lesser of two {{type}} numbers
///
/// @param x a fixed point number
/// @param y the other fixed point number
/// @return the lesser of x and y
static inline {{type}} {{prefix}}_min({{type}} x, {{type}} y) {
    return {{prefix}}_lt(x, y) ? x : y;
}

//==========================================================
// Trigonometric functions
//==========================================================

/// Computes the sine of a given angle. The result is accurate to within ±{{macro}}_EPSILON
///
/// @param angle the angle
/// @return the sine of the angle
{{type}} {{prefix}}_sin({{type}} angle);

/// Computes the cosine of a given angle. The result is accurate to within ±{{macro}}_EPSILON
///
/// @param angle the angle
/// @return the cosine of the angle
{{type}} {{prefix}}_cos({{type}} angle);

/// Computes the tangent of a given angle. The result is accurate to within ±{{macro}}_EPSILON for
/// angles not in the ranges -0.52π..-0.48π and 0.48π..0.52π. Near to the singlularities at ±π/2 the
/// absolute error increases. The relative error remains small (less than 1e-6) for all values a
/// outside -(π/2 + 1e-6)..-(π/2 - 1e-6) and (π/2 - 1e-6)..(π/2 + 1e-6). Large values are saturated
/// at {{macro}}_MAX or {{macro}}_MIN depending on the quadrant
///
/// @param angle the angle
/// @return the tangent of the angle
{{type}} {{prefix}}_tan({{type}} angle);

#ifdef __cplusplus
}
#endif
