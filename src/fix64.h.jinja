{#- jinja2 template for fix64.h -#}

{{autogen_comment}}

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <float.h>
#include <limits.h>
#include <math.h>
#include <stdint.h>

#ifndef __has_builtin
    #define __has_builtin(_) 0
#endif
#if __has_builtin(__builtin_expect_with_probability)
    // Use __builtin_expect_with_probability if available with a probability of 0.9. GCC already
    // uses 0.9 by default for __builtin_expect, but Clang uses 1.0. This makes Clang perform
    // optimisations such as replacing cmov with branches which make the expected case marginally
    // faster while making the other case significantly slower. To get around this we explicitly
    // use 0.9 probability which will reorder branches, etc, but otherwise won't go overboard.
    #define FIX64_LIKELY(cond) __builtin_expect_with_probability((cond), 1, 0.9)
    #define FIX64_UNLIKELY(cond) __builtin_expect_with_probability((cond), 0, 0.9)
#elif __has_builtin(__builtin_expect)
    #define FIX64_LIKELY(cond) __builtin_expect((cond), 1)
    #define FIX64_UNLIKELY(cond) __builtin_expect((cond), 0)
#else
    #define FIX64_LIKELY(cond) (cond)
    #define FIX64_UNLIKELY(cond) (cond)
#endif

#if FLT_RADIX != 2
    #error "FLT_RADIX != 2 not currently supported!"
#endif

// Avoids warnings
#ifdef __SIZEOF_INT128__
    __extension__ typedef __int128 int128_t;
#else
    #error "Unsupported compiler/architecture; no 128-bit integer type defined"
#endif

//==========================================================
// Type definitions
//==========================================================

/// Signed fixed point Q31.32 type
typedef struct {
    int64_t repr;
} fix64_t;

//==========================================================
// Defines
//==========================================================

/// Number of fractional bits for fix64_t
#define FIX64_FRAC_BITS 32
/// Number of integral bits for fix64_t (excluding sign bit)
#define FIX64_INT_BITS  31
/// Number of significant bits for fix64_t (excluding sign bit)
#define FIX64_BITS      (FIX64_INT_BITS + FIX64_FRAC_BITS)
/// Maximum value for a fix64_t
#define FIX64_MAX       ((fix64_t){INT64_MAX})
/// Minimum value for a fix64_t
#define FIX64_MIN       ((fix64_t){INT64_MIN})
/// Smallest positive non-zero value for fix64_t
#define FIX64_EPSILON   ((fix64_t){INT64_C(1)})

//==========================================================
// Literals
//==========================================================

// This function call will be inlined by the compiler, Clang 13 does this even with -Og

/// Creates a fix64_t literal, for example FIX64_C(2.5)
#define FIX64_C(x) (fix64_from_ldbl((long double)(x##L)))

//==========================================================
// Constants
//==========================================================

{% for name, c in consts.items() %}
/// fix64_t constant {{c.str}}
#define FIX64_{{name | upper}} {{" " * (9 - (name | length))-}}
    ((fix64_t){ {{-const(c.val, digits=9)-}} })
{% endfor %}

//==========================================================
// Generic functions
//==========================================================

// _Generic is only available since C11
#if __STDC_VERSION__ >= 201112L
/// Generic macro to convert a floating point type to fix64_t
#define fix64_from(x) _Generic((x), \
{% for type, i in ints.items() %}
        {{type}}: fix64_from_{{i.short}}, \
{% endfor %}
{% for type, f in floats.items() %}
        {{type}}: fix64_from_{{f.short}}, \
{% endfor %}
    )(x)
#endif

//==========================================================
// Conversion functions
//==========================================================

{% for type, i in ints.items() %}
/// Converts a fix64_t to an {{type}}
///
/// @param value the fix64_t value to convert
/// @return converted {{type}} value
static inline {{type}} fix64_to_{{i.short}}(fix64_t value) {
    int64_t result = (value.repr >> FIX64_FRAC_BITS);
    if (result > {{i.short | upper}}_MAX) {
        result = {{i.short | upper}}_MAX;
    }
{%- if i.signed %} {# -#}
    else if (result < {{i.short | upper}}_MIN) {
        result = {{i.short | upper}}_MIN;
    }
{%- endif +%}
    return result;
}

{% endfor -%}

{% for type, i in ints.items() %}
/// Converts an {{type}} to a fix64_t
///
/// @param value the {{type}} value to convert
/// @return converted fix64_t value
static inline fix64_t fix64_from_{{i.short}}({{type}} value) {
    int128_t result = ((int128_t)value << FIX64_FRAC_BITS);
    if (result > INT64_MAX) {
        result = INT64_MAX;
    }
{%- if i.signed %} {# -#}
    else if (result < INT64_MIN) {
        result = INT64_MIN;
    }
{%- endif +%}
    return (fix64_t){(int64_t)result};
}

{% endfor -%}

{% for type, f in floats.items() %}
/// Converts a fix64_t to a {{type}}
///
/// @param value the fix64_t value to convert
/// @return converted {{type}} value
static inline {{type}} fix64_to_{{f.short}}(fix64_t value) {
    return (({{type}})(value.repr) / ({{type}})(INT64_C(1) << FIX64_FRAC_BITS));
}

{% endfor -%}

// Note: for (sort-of) efficient float to fixed saturating conversions, we rely on integer limits
// converted to float and rounded towards zero. Unfortunately compilers don't have good support for
// fesetround (GCC for example will reorder fesetround calls relative to float casts). Instead the
// limits are calculated by zeroing the LSBs of the integral max so that has as many significant
// bits as the floating point mantissa. This way the exact value is preserved when casting. The
// min is currently just set as -max since calculating the actual minimum is more tricky. At worst
// we're one interval off, but we can compensate for this by only comparing < min when saturating.
// Values == min are converted as usual so if min is off-by-one the result won't be.

{% for type, f in floats.items() %}
/// Converts a {{type}} to fix64_t
///
/// Saturates if input is outside of fix64_t's range. Undefined behaviour if input is NaN
///
/// @param value the {{type}} value to convert
/// @return converted fix64_t value
static inline fix64_t fix64_from_{{f.short}}({{type}} value) {
#if {{f.short | upper}}_MANT_DIG >= FIX64_BITS
    static const {{type}} max = INT64_MAX;
    static const {{type}} min = INT64_MIN;
#else
    static const {{type}} max = (INT64_MAX & ~((INT64_C(1) << {#
        #}(FIX64_BITS - {{f.short | upper}}_MANT_DIG)) - 1));
    static const {{type}} min = -max;
#endif
{% if type == "long double" %}
    // Note: clang fails to optimise out call to exp2l, so we use a bit shift instead. A long
    // double is more than large enough to store the result so the compiler doesn't complain
    // like it does with float (even though float can accurately hold any power of 2 too).
    value = value * (INT64_C(1) << FIX64_FRAC_BITS);
{% else %}
    value = value * exp2{{f.suffix}}(FIX64_FRAC_BITS);
{% endif %}
    value += copysign{{f.suffix}}(0.5{{f.suffix}}, value);

    int64_t repr;
    if (FIX64_UNLIKELY(value > max)) {
        repr = INT64_MAX;
    } else if (FIX64_UNLIKELY(value < min)) {
        repr = INT64_MIN;
    } else {
        repr = (int64_t)value;
    }

    return (fix64_t){repr};
}

{% endfor -%}

//==========================================================
// Comparison functions
//==========================================================

/// Compares two fix64_t values for equality
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if the values are equal, 0 otherwise
static inline int fix64_eq(fix64_t lhs, fix64_t rhs) {
    return (lhs.repr == rhs.repr);
}

/// Compares two fix64_t values for inequality
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if the values are not equal, 0 otherwise
static inline int fix64_neq(fix64_t lhs, fix64_t rhs) {
    return (lhs.repr != rhs.repr);
}

/// Check if a fix64_t is less than another
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if lhs is less than rhs, 0 otherwise
static inline int fix64_lt(fix64_t lhs, fix64_t rhs) {
    return (lhs.repr < rhs.repr);
}

/// Check if a fix64_t is greater than another
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if lhs is greater than rhs, 0 otherwise
static inline int fix64_gt(fix64_t lhs, fix64_t rhs) {
    return (lhs.repr > rhs.repr);
}

/// Check if a fix64_t is less than or equal to another
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if lhs is less than or equal to rhs, 0 otherwise
static inline int fix64_lte(fix64_t lhs, fix64_t rhs) {
    return (lhs.repr <= rhs.repr);
}

/// Check if a fix64_t is greater than or equal to another
///
/// @param lhs left hand side for comparison
/// @param rhs right hand side for comparison
/// @return 1 if lhs is greater than or equal to rhs, 0 otherwise
static inline int fix64_gte(fix64_t lhs, fix64_t rhs) {
    return (lhs.repr >= rhs.repr);
}

//==========================================================
// Arithmetic functions
//==========================================================

/// Negates a fix64_t number. Note: fix64_neg(FIX64_MIN) returns
/// FIX64_MAX.
///
/// @param arg number to negate
/// @return the negative of arg
static inline fix64_t fix64_neg(fix64_t arg) {
    if (FIX64_UNLIKELY(arg.repr < -INT64_MAX)) {
        return FIX64_MAX;
    }
    return (fix64_t){-arg.repr};
}

/// Addition of two fix64_t numbers
///
/// @param lhs left hand side for the addition
/// @param rhs right hand side for the addition
/// @return the sum of the two inputs
static inline fix64_t fix64_add(fix64_t lhs, fix64_t rhs) {
    return (fix64_t){lhs.repr + rhs.repr};
}

/// Saturating addition of two fix64_t numbers
///
/// @param lhs left hand side for the addition
/// @param rhs right hand side for the addition
/// @return the sum of the two inputs
static inline fix64_t fix64_add_sat(fix64_t lhs, fix64_t rhs) {
    // TODO add compiler-agnostic version? GCC/Clang currently produce pretty suboptimal signed
    // saturation code for any implementation that doesn't use __builtin_*_overflow
    fix64_t result;
    int overflow = __builtin_add_overflow(lhs.repr, rhs.repr, &result.repr);
    if (FIX64_UNLIKELY(overflow)) {
        result = (rhs.repr < 0) ? FIX64_MIN : FIX64_MAX;
    }
    return result;
}

/// Subtraction of two fix64_t numbers
///
/// @param lhs left hand side for the subtraction
/// @param rhs right hand side for the subtraction
/// @return the difference of the two inputs
static inline fix64_t fix64_sub(fix64_t lhs, fix64_t rhs) {
    return (fix64_t){lhs.repr - rhs.repr};
}

/// Saturating subtraction of two fix64 numbers
///
/// @param lhs left hand side for the subtraction
/// @param rhs right hand side for the subtraction
/// @return the difference of the two inputs
static inline fix64_t fix64_sub_sat(fix64_t lhs, fix64_t rhs) {
    // TODO add compiler-agnostic version? GCC/Clang currently produce pretty suboptimal signed
    // saturation code for any implementation that doesn't use __builtin_*_overflow
    fix64_t result;
    int overflow = __builtin_sub_overflow(lhs.repr, rhs.repr, &result.repr);
    if (FIX64_UNLIKELY(overflow)) {
        result = (rhs.repr > 0) ? FIX64_MIN : FIX64_MAX;
    }
    return result;
}

/// Multiplication of two fix64_t numbers
///
/// @param lhs left hand side for the multiplication
/// @param rhs right hand side for the multiplication
/// @return the product of the two inputs
static inline fix64_t fix64_mul(fix64_t lhs, fix64_t rhs) {
    // TODO don't rely on int128_t?
    int128_t result = ((int128_t)lhs.repr * rhs.repr);
    // add one to the bit below the LSB of the final result for rounding
    result += (INT64_C(1) << (FIX64_FRAC_BITS - 1));
    result >>= FIX64_FRAC_BITS;
    return (fix64_t){(int64_t)result};
}

/// Saturating multiplication of two fix64_t numbers
///
/// @param lhs left hand side for the multiplication
/// @param rhs right hand side for the multiplication
/// @return the product of the two inputs
static inline fix64_t fix64_mul_sat(fix64_t lhs, fix64_t rhs) {
    // TODO don't rely on int128_t?
    int128_t result = ((int128_t)lhs.repr * rhs.repr);
    // add one to the bit below the LSB of the final result for rounding
    result += (INT64_C(1) << (FIX64_FRAC_BITS - 1));
    result >>= FIX64_FRAC_BITS;
    if (FIX64_UNLIKELY(result > (int128_t)INT64_MAX)) {
        result = INT64_MAX;
    } else if (FIX64_UNLIKELY(result < (int128_t)INT64_MIN)) {
        result = INT64_MIN;
    }
    return (fix64_t){(int64_t)result};
}

/// Division of two fix64_t numbers. Result is rounded to the nearest representable value
///
/// @param lhs dividend side for the division
/// @param rhs divisor side for the division
/// @return the quotient of the two inputs
static inline fix64_t fix64_div(fix64_t lhs, fix64_t rhs) {
    // TODO don't rely on int128_t?
    int128_t dividend = ((int128_t)lhs.repr << FIX64_FRAC_BITS);
    if ((rhs.repr < 0) == (lhs.repr < 0)) {
        dividend += rhs.repr / 2; // if signs are same -> result is positive -> add for rounding
    } else {
        dividend -= rhs.repr / 2; // else subtract for rounding
    }
    int128_t result = dividend / rhs.repr;
    return (fix64_t){(int64_t)result};
}

/// Saturating division of two fix64_t numbers. Result is rounded to the nearest representable
/// value. Division by zero is saturated depending on the sign of the dividend
///
/// @param lhs dividend side for the division
/// @param rhs divisor side for the division
/// @return the quotient of the two inputs
static inline fix64_t fix64_div_sat(fix64_t lhs, fix64_t rhs) {
    if (FIX64_UNLIKELY(rhs.repr == 0)) {
        return (lhs.repr > 0) ? FIX64_MAX : FIX64_MIN;
    }

    // TODO don't rely on int128_t?
    int128_t dividend = ((int128_t)lhs.repr << FIX64_FRAC_BITS);
    if ((rhs.repr < 0) == (lhs.repr < 0)) {
        dividend += rhs.repr / 2; // if signs are same -> result is positive -> add for rounding
    } else {
        dividend -= rhs.repr / 2; // else subtract for rounding
    }
    int128_t result = dividend / rhs.repr;
    if (FIX64_UNLIKELY(result > (int128_t)INT64_MAX)) {
        result = INT64_MAX;
    } else if (FIX64_UNLIKELY(result < (int128_t)INT64_MIN)) {
        result = INT64_MIN;
    }
    return (fix64_t){(int64_t)result};
}

//==========================================================
// Basic math functions
//==========================================================

/// Rounds down to the nearest integral value less than or equal to the fixed point argument
///
/// @param arg the fixed point number to floor
/// @return the floor of arg
static inline fix64_t fix64_floor(fix64_t arg) {
    return (fix64_t){(arg.repr >> FIX64_FRAC_BITS) << FIX64_FRAC_BITS};
}

/// Rounds up to the nearest integral value greater than or equal to the fixed point argument
///
/// @param arg the fixed point number to ceil
/// @return the ceil of arg
static inline fix64_t fix64_ceil(fix64_t arg) {
    // Add use floor and add (1 - eps) for rounding up
    return fix64_floor(fix64_add(arg, fix64_sub(FIX64_ONE, FIX64_EPSILON)));
}

/// Rounds the fixed point argument to the nearest integral value. Halfway values round away from
/// zero
///
/// @param arg the fixed point number to round
/// @return the rounded value
static inline fix64_t fix64_round(fix64_t arg) {
    if (fix64_lt(arg, FIX64_ZERO)) {
        return fix64_floor(fix64_add(arg, fix64_sub(FIX64_HALF, FIX64_EPSILON)));
    } else {
        return fix64_floor(fix64_add(arg, FIX64_HALF));
    }
}

/// Rounds the fixed point number towards zero
///
/// @param arg the fixed point number to truncate
/// @return the truncated value
static inline fix64_t fix64_trunc(fix64_t arg) {
    if (fix64_lt(arg, FIX64_ZERO)) {
        return fix64_ceil(arg);
    } else {
        return fix64_floor(arg);
    }
}

/// Absolute value of a fix64_t number. Note: fix64_abs(FIX64_MIN) returns FIX64_MAX.
///
/// @param arg fixed point number
/// @return absolute value of arg
static inline fix64_t fix64_abs(fix64_t arg) {
    if (fix64_lt(arg, FIX64_ZERO)) {
        return fix64_neg(arg);
    } else {
        return arg;
    }
}

/// Returns the greater of two fix64_t numbers
///
/// @param x a fixed point number
/// @param y the other fixed point number
/// @return the greater of x and y
static inline fix64_t fix64_max(fix64_t x, fix64_t y) {
    return fix64_gt(x, y) ? x : y;
}

/// Returns the lesser of two fix64_t numbers
///
/// @param x a fixed point number
/// @param y the other fixed point number
/// @return the lesser of x and y
static inline fix64_t fix64_min(fix64_t x, fix64_t y) {
    return fix64_lt(x, y) ? x : y;
}

/// Returns the absolute value of the difference between two numbers. The difference will saturate
/// at FIX64_MAX
///
/// @param x a fixed point number
/// @param y the other fixed point number
/// @return the absolute difference
static inline fix64_t fix64_dim(fix64_t x, fix64_t y) {
    return fix64_abs(fix64_sub_sat(x, y));
}

//==========================================================
// Exponential functions
//==========================================================

/// Returns e raised to the given power
///
/// @param arg fixed point number
/// @return e raised to the given power
fix64_t fix64_exp(fix64_t arg);

/// Returns 2 raised to the given power
///
/// @param arg fixed point number
/// @return 2 raised to the given power
fix64_t fix64_exp2(fix64_t arg);

/// Returns e raised to the given power, minus one
///
/// @param arg fixed point number
/// @return e raised to the given power, minus one
static inline fix64_t fix64_expm1(fix64_t arg) {
    return fix64_sub(fix64_exp(arg), FIX64_ONE);
}

/// Returns natural (base e) logarithm of a number
///
/// @param arg fixed point number
/// @return the natural logarithm
fix64_t fix64_log(fix64_t arg);

/// Returns base 10 logarithm of a number
///
/// @param arg fixed point number
/// @return the base 10 logarithm
fix64_t fix64_log10(fix64_t arg);

/// Returns base 2 logarithm of a number
///
/// @param arg fixed point number
/// @return the base 2 logarithm
fix64_t fix64_log2(fix64_t arg);

/// Returns natural (base e) logarithm of 1 plus the argument
///
/// @param arg fixed point number
/// @return the natural logarithm of 1 plus the argument
static inline fix64_t fix64_log1p(fix64_t arg) {
    return fix64_log(fix64_add_sat(FIX64_ONE, arg));
}

//==========================================================
// Power functions
//==========================================================

/// Raises a fixed point number to the power of another
///
/// @param x the base
/// @param y the exponent
/// @return the base raised to the power of the exponent
fix64_t fix64_pow(fix64_t x, fix64_t y);

/// Calculates a number's square root
///
/// @param arg fixed point number
/// @return the square root
fix64_t fix64_sqrt(fix64_t arg);

/// Calculates a number's cube root
///
/// @param arg fixed point number
/// @return the cube root
fix64_t fix64_cbrt(fix64_t arg);

/// Calculates the hypotenuse of a right-angled triangle given the two other sides
///
/// @param x one side of the triangle
/// @param y the other side of the triangle
/// @return the length of the hypotenuse
fix64_t fix64_hypot(fix64_t x, fix64_t y);

//==========================================================
// Trigonometric functions
//==========================================================

/// Computes the sine of a given angle. The result is extremely accurate, with a maximum error of
/// +/-FIX64_EPSILON for <0.01% of inputs.
///
/// @param angle the angle
/// @return the sine of the angle
fix64_t fix64_sin(fix64_t angle);

/// Computes the cosine of a given angle. The result is extremely accurate, with a maximum error of
/// +/-FIX64_EPSILON for <0.01% of inputs.
///
/// @param angle the angle
/// @return the cosine of the angle
fix64_t fix64_cos(fix64_t angle);

/// Computes the tangent of a given angle. The result is extremely accurate, with a maximum error
/// of +/-FIX64_EPSILON for <0.01% of angles >0.0001pi from a singularity. Near the singularities
/// at +/-pi/2 the absolute error increases. The relative error remains small (less than 1e-12).
/// Extremely large results are saturated at FIX64_MAX or FIX64_MIN depending on the sign.
///
/// @param angle the angle
/// @return the tangent of the angle
fix64_t fix64_tan(fix64_t angle);

/// Computes arc sine of a given number
///
/// @param arg fixed point number
/// @return the arc sine
fix64_t fix64_asin(fix64_t arg);

/// Computes arc cosine of a given number
///
/// @param arg fixed point number
/// @return the arc cosine
fix64_t fix64_acos(fix64_t arg);

/// Computes 2 argument arc tangent of a given pair of numbers
///
/// @param x the horizontal component
/// @param y the vertical component
/// @return the arc tangent of y/x, taking their signs into account
fix64_t fix64_atan2(fix64_t x, fix64_t y);

/// Computes arc tangent of a given number
///
/// @param arg fixed point number
/// @return the arc tangent
static inline fix64_t fix64_atan(fix64_t arg) {
    return fix64_atan2(arg, FIX64_ONE);
}

//==========================================================
// Error and Gamma functions
//==========================================================

/// computes error function
///
/// @param arg a fixed point number
/// @return the result of the error function
fix64_t fix64_erf(fix64_t arg);

/// computes complementary error function
///
/// @param arg a fixed point number
/// @return the result of the complementary error function
fix64_t fix64_erfc(fix64_t arg);

/// computes gamma function
///
/// @param arg a fixed point number
/// @return the result of the gamma function
fix64_t fix64_tgamma(fix64_t arg);

/// computes natural logarithm of the gamma function
///
/// @param arg a fixed point number
/// @return the natural logarithm of the result of the gamma function
fix64_t fix64_lgamma(fix64_t arg);

#ifdef __cplusplus
}
#endif
