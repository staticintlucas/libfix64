{#- jinja2 template for fix64_exp.c -#}

{{autogen_comment}}

{% set exp_frac_bits = 64 %}
{% set mul_frac_bits = 63 %} {# Need one int bit to be able to store log2(e) #}

#include "fix64.h"

#include <stddef.h>
#include <stdint.h>

// Number fractional bits
#define EXP_FRAC_BITS {{exp_frac_bits}}
#define MUL_FRAC_BITS {{mul_frac_bits}}

static inline unsigned clz(uint64_t arg) {
    unsigned result;
    #if __has_builtin(__builtin_clzll)
        result = __builtin_clzll(arg);
    #else
        result = 0;
        for (uint64_t sh = (CHAR_BIT * sizeof(uint64_t)) >> 1; sh; sh >>= 1) {
            uint64_t tmp = arg >> sh;
            if (tmp) {
                arg = tmp;
            } else {
                result |= sh;
            }
        }
    #endif
    return result;
}

// Calculates 2**x-1 for UQ0.64 fixed point numbers
static uint64_t chebyshev_exp2m1_impl(uint64_t arg) {
    static const uint64_t chebyshev_coefs[{{chebyshev_coefs["exp2m1"] | length}}] = {
{% for coef in chebyshev_coefs["exp2m1"] %}
        {{const(coef, frac_bits=exp_frac_bits, digits=16)}},
{% endfor %}
    };

    uint64_t powers[{{chebyshev_coefs["exp2m1"] | length}}];
    powers[0] = 0; // Should be 1.0 which is too big for UQ0.64. But coefs[0] = 0 so it doesn't matter
    powers[1] = arg;
    for (size_t i = 2; i < sizeof(powers) / sizeof(powers[0]); i++) {
        powers[i] = ((uint128_t)powers[i - 1] * arg) >> EXP_FRAC_BITS;
    }

    uint64_t sum = 0; // UQ0.64
    for (size_t i = 0; i < sizeof(chebyshev_coefs) / sizeof(chebyshev_coefs[0]); i++) {
        sum += ((uint128_t)powers[i] * chebyshev_coefs[i]) >> EXP_FRAC_BITS;
    }

    return sum;
}

// Calculates log2(1+x) for UQ0.64 fixed point numbers
// Based on Clay Turner's paper: http://www.claysturner.com/dsp/BinaryLogarithm.pdf
static uint64_t turner_log21p_impl(uint64_t arg) {
    uint64_t result = 0;
    for (size_t i = 0; i < (FIX64_FRAC_BITS + 1); i++) {
        // (1+x)**2 - 1 == 2*x + x**2
        uint128_t arg128 = ((uint128_t)arg << 1) + (((uint128_t)arg * arg) >> 64); // UQ64.64

        result <<= 1;
        if (arg128 >> EXP_FRAC_BITS) { // i.e. if (arg128 >= 1.0)
            // arg+1 = (arg+1)/2 => arg = (arg-1)/2
            arg = (uint64_t)((arg128 - ((uint128_t)1 << EXP_FRAC_BITS)) >> 1);
            result |= 1;
        } else {
            arg = (uint64_t)arg128;
        }
    }
    return result << (EXP_FRAC_BITS - (FIX64_FRAC_BITS + 1));
}

static fix64_t fix64_exp2_inner(int64_t ipart, uint64_t fpart) {
    if (ipart >= FIX64_INT_BITS) {
        return FIX64_MAX;
    } else if (ipart < -FIX64_FRAC_BITS - 1) {
        return FIX64_ZERO;
    }

    uint128_t result = ((uint128_t)1 << EXP_FRAC_BITS) | chebyshev_exp2m1_impl(fpart); // UQ1.64

    result += ((uint128_t)1 << (EXP_FRAC_BITS - FIX64_FRAC_BITS - 1 - ipart)); // rounding
    result >>= (EXP_FRAC_BITS - FIX64_FRAC_BITS - ipart); // UQ31.32

    return (fix64_t){ result };
}

fix64_t fix64_exp(fix64_t arg) {
    int128_t arg_log2e = (int128_t)arg.repr * (int128_t)
        {{-const(consts.log2e.val, frac_bits=mul_frac_bits)}}; // Q32.95
    arg_log2e += (int128_t)1 << (FIX64_FRAC_BITS + MUL_FRAC_BITS - 1 - EXP_FRAC_BITS); // rounding
    arg_log2e >>= FIX64_FRAC_BITS + MUL_FRAC_BITS - EXP_FRAC_BITS; // Q32.64

    int64_t ipart = (arg_log2e >> EXP_FRAC_BITS);
    uint64_t fpart = arg_log2e & (((int128_t)1 << EXP_FRAC_BITS) - 1);

    return fix64_exp2_inner(ipart, fpart);
}

fix64_t fix64_exp2(fix64_t arg) {
    int64_t ipart = fix64_to_int(arg); // Q31.0
    uint64_t fpart = (arg.repr - fix64_from_int(ipart).repr) << (EXP_FRAC_BITS - FIX64_FRAC_BITS); // UQ0.64

    return fix64_exp2_inner(ipart, fpart);
}

fix64_t fix64_log(fix64_t arg) {
    return FIX64_ZERO;
}

fix64_t fix64_log10(fix64_t arg) {
    return FIX64_ZERO;
}

fix64_t fix64_log2(fix64_t arg) {
    if (fix64_lte(arg, FIX64_ZERO)) {
        return FIX64_MIN;
    }

    int64_t lz = clz(arg.repr); // Q31.0
    uint64_t fpart = arg.repr << (lz + 1); // Q0.64
    int128_t result = ((int128_t)(FIX64_INT_BITS - lz) << EXP_FRAC_BITS) +
        turner_log21p_impl(fpart); // Q31.64
    result += (int128_t)1 << (EXP_FRAC_BITS - FIX64_FRAC_BITS - 1); // rounding
    result >>= (EXP_FRAC_BITS - FIX64_FRAC_BITS); // Q31.32

    return (fix64_t){ result };
}
